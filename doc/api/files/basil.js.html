<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>basil.js - basil.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;basiljs.ch&#x2F;basil2.jpg" title="basil.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/b.html">b</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: basil.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
#target &quot;InDesign&quot;;

(function(glob, app, undef) {
  &#x2F;**
   * @class b
   * @static
   *&#x2F;
  var pub = {};


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; constants
  
  pub.VERSION = &quot;0.1&quot;;
  pub.PT = &quot;pt&quot;;
  pub.PX = &quot;px&quot;;
  pub.CM = &quot;cm&quot;;
  pub.MM = &quot;mm&quot;;
  pub.CORNER = &quot;corner&quot;;
  pub.CORNERS = &quot;corners&quot;;
  pub.CENTER = &quot;center&quot;;
  pub.RADIUS = &quot;radius&quot;;
  pub.TWO_PI = Math.PI*2;
  pub.PI = Math.PI;
  pub.HALF_PI = Math.PI&#x2F;2;
  pub.QUARTER_PI = Math.PI&#x2F;4;
  
  var ERROR_PREFIX = &quot;\n\n### Basil Error -&gt; &quot;,
    WARNING_PREFIX = &quot;### Basil Warning -&gt; &quot;;


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; public vars
  
  &#x2F;**
   * System variable which stores the width of the current page.
   * @property width {Number}
   *&#x2F;
  pub.width = null;

  &#x2F;**
   * System variable which stores the height of the current page.
   * @property height {Number}
   *&#x2F;
  pub.height = null;

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; private vars
  var currDoc = null,
    currPage = null,
    currLayer = null,
    currUnits = null,
    currMatrix = null,
    matrixStack = null,
    currColorMode = null,
    currFillColor = null,
    currStrokeColor = null,
    currStrokeTint = null,
    currFillTint = null,
    currStrokeWeight = null,
    currRectMode = null,
    currEllipseMode = null,
    noneSwatchColor = null,
    start = null,
    currFont = null,
    currFontSize = null,
    currAlign = null,
    currYAlign = null,
    currLeading = null,
    currKerning = null,
    currTracking = null,
    currImageMode = null;

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; global functions

  &#x2F;&#x2F;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;filter
  if (!Array.prototype.filter) {
    Array.prototype.filter = function(fun) {
      if (this == null) throw new TypeError();
      var t = Object(this);
      var len = t.length &gt;&gt;&gt; 0;
      if (typeof fun != &quot;function&quot;) throw new TypeError();
      var res = [];
      var thisp = arguments[1];
      for (var i = 0; i &lt; len; i++) {
        if (i in t) {
          var val = t[i]; &#x2F;&#x2F; in case fun mutates this
          if (fun.call(thisp, val, i, t)) res.push(val);
        }
      }
      return res;
    };
  }

  if (!glob.forEach) {
    glob.forEach = function(collection, cb) {
      for (var i = 0, len = collection.length; i &lt; len; i++) {
        cb(collection[i],i);
      }
    };
  }
  
  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Structure
  
  &#x2F;**
   * Suspends the calling thread for a number of milliseconds.
   * During a sleep period, checks at 100 millisecond intervals to see whether the sleep should be terminated. 
   * @param  {Number} milliseconds  The delay time in milliseconds
   *&#x2F;
  pub.delay = function (milliseconds) {
    $.sleep(milliseconds);
  };

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Environment
  
  &#x2F;**
   * Sets or possibly creates the current document and returns it. 
   * If the param doc is not given the current document gets set to the active document 
   * in the application. If no document at all is open, a new document gets created.
   * 
   * @method doc
   * @param  {Document} [doc] The document to set the current document to
   * @return {Document} The current document instance
   *&#x2F;
  pub.doc = function(doc) {
    if (doc instanceof Document) {
      setCurrDoc(doc);
    }
    return currentDoc();
  };

  &#x2F;**
   * Closes the current document.
   * 
   * @method close
   * @param  {SaveOptions} [saveOptions] The indesign SaveOptions constant
   * @param  {File} [file] The indesign file instance to save the document to
   *&#x2F;
  pub.close = function(saveOptions, file) {
    var doc = currentDoc();
    if (doc) {
      doc.close(saveOptions, file);
      resetCurrDoc();
    }
  }

  &#x2F;**
   * Returns the current page and sets it if argument page is given.
   * 
   * @method page
   * @param  {Page|Number} [page] The page or page index to set the current page to
   * @return {Page} The current page instance
   *&#x2F;
  pub.page = function(page) {
    if (page instanceof Page) {
      currPage = page;
    } else if (typeof page === &#x27;number&#x27;) {
      var tempPage = currentDoc().pages[page];
      try {
        tempPage.id;
      } catch (e) {
        error(&#x27;Page &#x27; + page + &#x27; does not exist.&#x27;);
      }
      currPage = tempPage;
    }
    updatePublicPageSizeVars();
    return currentPage();
  };

  &#x2F;**
   * Returns the current layer and sets it if argument layer is given.
   * 
   * @method layer
   * @param  {Layer|String} [layer] The layer or layer name to set the current layer to
   * @return {Layer} The current layer instance
   *&#x2F;
  pub.layer = function(layer) {
    if (layer instanceof Layer) {
      currLayer = layer;
    } else if (typeof layer === &#x27;string&#x27;) {
      var layers = currentDoc().layers;
      currLayer = layers.item(layer);
      if (!currLayer.isValid) {
        currLayer = layers.add({name: layer});
      }
    }
    return currentLayer();
  };

  &#x2F;**
   * Sets the units of the document (like right clicking the rulers).
   * 
   * @method units
   * @param  {Constant} [units] Supported units: PT, PX, CM or MM
   * @return {Constant} Current unit setting
   *&#x2F;
  pub.units = function (units) {
    if (!units) return currUnits;

    if (units === pub.CM || 
        units === pub.MM ||
        units === pub.PT || 
        units === pub.PX ) {
      var unitType = null;
      if      (units === pub.CM) unitType = MeasurementUnits.centimeters;
      else if (units === pub.MM) unitType = MeasurementUnits.millimeters;
      else if (units === pub.PT) unitType = MeasurementUnits.points;
      else if (units === pub.PX) unitType = MeasurementUnits.pixels;
      var doc = currentDoc(); 
      with (doc.viewPreferences){
        &#x2F;&#x2F;* MeasurementUnits.agates
        &#x2F;&#x2F;* MeasurementUnits.picas
        &#x2F;&#x2F;* MeasurementUnits.points
        &#x2F;&#x2F;* MeasurementUnits.inches
        &#x2F;&#x2F;* MeasurementUnits.inchesDecimal
        &#x2F;&#x2F;* MeasurementUnits.millimeters
        &#x2F;&#x2F;* MeasurementUnits.centimeters
        &#x2F;&#x2F;* MeasurementUnits.ciceros
        horizontalMeasurementUnits = unitType; 
        verticalMeasurementUnits = unitType;
      }
      currUnits = units;
    } else {
      error(&quot;Not supported unit&quot;);
    }
    return currUnits;
  }


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Data

  &#x2F;&#x2F; -- Conversion --
  pub.binary = function(num, numBits) {
    var bit;
    if (numBits &gt; 0) bit = numBits;
    else if (num instanceof Char) {
      bit = 16;
      num |= 0
    } else {
      bit = 32;
      while (bit &gt; 1 &amp;&amp; !(num &gt;&gt;&gt; bit - 1 &amp; 1)) bit--
    }
    var result = &quot;&quot;;
    while (bit &gt; 0) result += num &gt;&gt;&gt; --bit &amp; 1 ? &quot;1&quot; : &quot;0&quot;;
    return result
  };
  pub.unbinary = function(binaryString) {
    var i = binaryString.length - 1,
      mask = 1,
      result = 0;
    while (i &gt;= 0) {
      var ch = binaryString[i--];
      if (ch !== &quot;0&quot; &amp;&amp; ch !== &quot;1&quot;) throw &quot;the value passed into unbinary was not an 8 bit binary number&quot;;
      if (ch === &quot;1&quot;) result += mask;
      mask &lt;&lt;= 1
    }
    return result
  };

  var decimalToHex = function(d, padding) {
    padding = padding === undef || padding === null ? padding = 8 : padding;
    if (d &lt; 0) d = 4294967295 + d + 1;
    var hex = Number(d).toString(16).toUpperCase();
    while (hex.length &lt; padding) hex = &quot;0&quot; + hex;
    if (hex.length &gt;= padding) hex = hex.substring(hex.length - padding, hex.length);
    return hex
  };
  pub.hex = function(value, len) {
    if (arguments.length === 1) if (value instanceof Char) len = 4;
    else len = 8;
    return decimalToHex(value, len)
  };

  function unhexScalar(hex) {
    var value = parseInt(&quot;0x&quot; + hex, 16);
    if (value &gt; 2147483647) value -= 4294967296;
    return value
  }
  pub.unhex = function(hex) {
    if (hex instanceof Array) {
      var arr = [];
      for (var i = 0; i &lt; hex.length; i++) arr.push(unhexScalar(hex[i]));
      return arr
    }
    return unhexScalar(hex)
  };


  &#x2F;&#x2F; -- String Functions --
  pub.join = function(array, seperator) {
    return array.join(seperator)
  };

  pub.split = function(str, delim) {
    return str.split(delim)
  };

  pub.match = function(str, regexp) {
    return str.match(regexp)
  };

  pub.matchAll = function(aString, aRegExp) {
    var results = [],
      latest;
    var regexp = new RegExp(aRegExp, &quot;g&quot;);
    while ((latest = regexp.exec(aString)) !== null) {
      results.push(latest);
      if (latest[0].length === 0)++regexp.lastIndex
    }
    return results.length &gt; 0 ? results : null
  };

  function nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group) {
    var sign = value &lt; 0 ? minus : plus;
    var autoDetectDecimals = rightDigits === 0;
    var rightDigitsOfDefault = rightDigits === undef || rightDigits &lt; 0 ? 0 : rightDigits;
    var absValue = Math.abs(value);
    if (autoDetectDecimals) {
      rightDigitsOfDefault = 1;
      absValue *= 10;
      while (Math.abs(Math.round(absValue) - absValue) &gt; 1.0E-6 &amp;&amp; rightDigitsOfDefault &lt; 7) {
        ++rightDigitsOfDefault;
        absValue *= 10
      }
    } else if (rightDigitsOfDefault !== 0) absValue *= Math.pow(10, rightDigitsOfDefault);
    var number, doubled = absValue * 2;
    if (Math.floor(absValue) === absValue) number = absValue;
    else if (Math.floor(doubled) === doubled) {
      var floored = Math.floor(absValue);
      number = floored + floored % 2
    } else number = Math.round(absValue);
    var buffer = &quot;&quot;;
    var totalDigits = leftDigits + rightDigitsOfDefault;
    while (totalDigits &gt; 0 || number &gt; 0) {
      totalDigits--;
      buffer = &quot;&quot; + number % 10 + buffer;
      number = Math.floor(number &#x2F; 10)
    }
    if (group !== undef) {
      var i = buffer.length - 3 - rightDigitsOfDefault;
      while (i &gt; 0) {
        buffer = buffer.substring(0, i) + group + buffer.substring(i);
        i -= 3
      }
    }
    if (rightDigitsOfDefault &gt; 0) return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) + &quot;.&quot; + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);
    return sign + buffer
  }
  function nfCore(value, plus, minus, leftDigits, rightDigits, group) {
    if (value instanceof Array) {
      var arr = [];
      for (var i = 0, len = value.length; i &lt; len; i++) arr.push(nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));
      return arr
    }
    return nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group)
  }
  pub.nf = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits)
  };
  pub.nfs = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot; &quot;, &quot;-&quot;, leftDigits, rightDigits)
  };
  pub.nfp = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;+&quot;, &quot;-&quot;, leftDigits, rightDigits)
  };
  pub.nfc = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits, &quot;,&quot;)
  };

  pub.splitTokens = function(str, tokens) {
    if (arguments.length === 1) tokens = &quot;\n\t\r\u000c &quot;;
    tokens = &quot;[&quot; + tokens + &quot;]&quot;;
    var ary = [];
    var index = 0;
    var pos = str.search(tokens);
    while (pos &gt;= 0) {
      if (pos === 0) str = str.substring(1);
      else {
        ary[index] = str.substring(0, pos);
        index++;
        str = str.substring(pos)
      }
      pos = str.search(tokens)
    }
    if (str.length &gt; 0) ary[index] = str;
    if (ary.length === 0) ary = undef;
    return ary
  };

  pub.trim = function(str) {
    if (str instanceof Array) {
      var arr = [];
      for (var i = 0; i &lt; str.length; i++) arr.push(str[i].replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;));
      return arr
    }
    return str.replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;)
  };

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Shape
  
  &#x2F;**
   * Draws an ellipse (oval) in the display window. An ellipse with an equal &lt;b&gt;width&lt;&#x2F;b&gt; and &lt;b&gt;height&lt;&#x2F;b&gt; is a circle.
   * The first two parameters set the location, the third sets the width, and the fourth sets the height.
   *
   * @method ellipse
   * @param  {Number} x Location X
   * @param  {Number} y Location Y
   * @param  {Number} w Width
   * @param  {Number} h Height
   * @return {Oval} New oval (n.b. in Adobe Scripting the corresponding type is Oval, not Ellipse)
   *&#x2F;
  pub.ellipse = function(x, y, w, h){
    if (arguments.length !== 4) error(&quot;Not enough parameters! Use: x, y, w, h&quot;);
    var ellipseBounds = [];
    if (currEllipseMode === pub.CORNER) {
      ellipseBounds[0] = y;
      ellipseBounds[1] = x;
      ellipseBounds[2] = (y+h);
      ellipseBounds[3] = (x+w);
    } else if (currEllipseMode === pub.CORNERS) {
      ellipseBounds[0] = y;
      ellipseBounds[1] = x;
      ellipseBounds[2] = h;
      ellipseBounds[3] = w;
    } else if (currEllipseMode === pub.CENTER) {
      ellipseBounds[0] = y-(h&#x2F;2);
      ellipseBounds[1] = x-(w&#x2F;2);
      ellipseBounds[2] = (y+h)-(h&#x2F;2);
      ellipseBounds[3] = (x+w)-(w&#x2F;2);
    } else if (currEllipseMode === pub.RADIUS) {
      ellipseBounds[0] = y-(h);
      ellipseBounds[1] = x-(w);
      ellipseBounds[2] = y+(h);
      ellipseBounds[3] = x+(w);
    }

    var ovals = app.activeWindow.activeSpread.ovals;
    var newOval = ovals.add( currentLayer() );
    with(newOval) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint; 
      fillColor = currFillColor;
      fillTint = currFillTint; 
      strokeColor = currStrokeColor;  
      geometricBounds = ellipseBounds;
    }

    if (currEllipseMode === pub.CENTER || currEllipseMode === pub.RADIUS) {
      newOval.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      newOval.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    } 
    return newOval;
  };

  &#x2F;**
   * Draws a line (a direct path between two points) to the page.
   *
   * @method line
   * @param  {Number} [x1] Point A x-value
   * @param  {Number} [y1] Point A y-value
   * @param  {Number} [x2] Point B x-value
   * @param  {Number} [y2] Point B y-value
   * @return {GraphicLine} New GraphicLine
   *&#x2F;
  pub.line = function(x1, y1, x2, y2) {
    var lines = currentPage().graphicLines;
    var newLine = lines.add( currentLayer() );
    with(newLine) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint; 
      fillColor = currFillColor;
      fillTint = currFillTint; 
      strokeColor = currStrokeColor;
    }
    newLine.paths.item(0).entirePath = [[x1, y1], [x2, y2]];
    newLine.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    return newLine;
  };

  &#x2F;**
   * Draws a rectangle to the page.
   *
   * @method rect
   * @param  {Number} x Position X
   * @param  {Number} y Position Y
   * @param  {Number} w Width
   * @param  {Number} h Height
   * @return {Rectangle} New rectangle
   *&#x2F;
  pub.rect = function(x, y, w, h){
    if (arguments.length !== 4) error(&quot;Not enough parameters! Use: x, y, w, h&quot;);
    var rectBounds = [];
    if (currRectMode === pub.CORNER) {
      rectBounds[0] = y;
      rectBounds[1] = x;
      rectBounds[2] = (y+h);
      rectBounds[3] = (x+w);
    } else if (currRectMode === pub.CORNERS) {
      rectBounds[0] = y;
      rectBounds[1] = x;
      rectBounds[2] = h;
      rectBounds[3] = w;
    } else if (currRectMode === pub.CENTER) {
      rectBounds[0] = y-(h&#x2F;2);
      rectBounds[1] = x-(w&#x2F;2);
      rectBounds[2] = (y+h)-(h&#x2F;2);
      rectBounds[3] = (x+w)-(w&#x2F;2);
    }
    
    var newRect = currentPage().rectangles.add( currentLayer() );
    with(newRect) {
      geometricBounds = rectBounds;
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      strokeColor = currStrokeColor;
    }

    if (currRectMode === pub.CENTER) {
      newRect.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      newRect.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    }
    return newRect;
  };

  &#x2F;&#x2F; -- Attributes --

  pub.rectMode = function (mode) {
    if (arguments.length === 0) return currRectMode;
    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER ) {
      currRectMode = mode;
      return currRectMode;
    } else {
      error(&quot;Unsupported rectMode. Use: CORNER, CORNERS, CENTER.&quot;);
    }
  };

  pub.ellipseMode = function (mode) {
    if (arguments.length === 0) return currEllipseMode;
    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER || mode === pub.RADIUS ) {
      currEllipseMode = mode;
      return currEllipseMode;
    } else {
      error(&quot;Unsupported ellipseMode. Use: CENTER, RADIUS, CORNER, CORNERS.&quot;);
    }
  };

  pub.strokeWeight = function (weight) {
    if (typeof weight === &#x27;string&#x27; || typeof weight === &#x27;number&#x27;) {
      currStrokeWeight = weight;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };
  


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Color
  
  &#x2F;**
   * Sets the color used to fill shapes.  
   * @method fill
   * @param  {Color|Swatch|Numbers} fillColor  Accepts a Color&#x2F;swatch or a string with the name of a color. Or values: C,M,Y,K &#x2F; R,G,B &#x2F; Grey
   *&#x2F;
  pub.fill = function (fillColor) {
    if (fillColor instanceof Color || fillColor instanceof Swatch) {
      currFillColor = fillColor;
    } else {
      if (arguments.length === 1) {
        currFillColor = pub.color(arguments[0]);
      } else if (arguments.length === 2) {
        currFillColor = pub.color(arguments[0],arguments[1]);
      } else if (arguments.length === 3) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2]);
      } else if (arguments.length === 4) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3]);
      } else if (arguments.length === 5) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
      } else {
        error(&quot;Wrong parameters. Use: &quot;
          + &quot;R,G,B,name or &quot;
          + &quot;C,M,Y,K,name. &quot;
          + &quot;Grey,name &quot;
          + &quot;Name is optional&quot;);
      }
    }
  };

  pub.noFill = function () {
    currFillColor = noneSwatchColor;
  };

  &#x2F;**
   * Sets the color used to draw lines and borders around shapes.  
   * @method stroke
   * @param  {Color|Swatch|Numbers} strokeColor  Accepts a Color&#x2F;swatch or a string with the name of a color. Or values: C,M,Y,K &#x2F; R,G,B &#x2F; Grey
   *&#x2F;
  pub.stroke = function (strokeColor) {
    if (strokeColor instanceof Color || strokeColor instanceof Swatch) {
      currStrokeColor = strokeColor;
    } else {
      if (arguments.length === 1) {
        currStrokeColor = pub.color(arguments[0]);
      } else if (arguments.length === 2) {
        currStrokeColor = pub.color(arguments[0],arguments[1]);
      } else if (arguments.length === 3) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2]);
      } else if (arguments.length === 4) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3]);
      } else if (arguments.length === 5) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
      } else {
        error(&quot;Wrong parameters. Use: &quot;
          + &quot;R,G,B,name or &quot;
          + &quot;C,M,Y,K,name. &quot;
          + &quot;Grey,name &quot;
          + &quot;Name is optional&quot;);
      }
    }
  };

  pub.noStroke = function () {
    currStrokeColor = noneSwatchColor;
  };

  &#x2F;**
   * Sets the tint of the color used to fill shapes.
   * 
   * @method fillTint
   * @param  {Number} tint Number from 0 to 100
   *&#x2F;
  pub.fillTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currFillTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Sets the tint of the color used to draw lines and borders around shapes.
   * 
   * @method strokeTint
   * @param  {Number} tint Number from 0 to 100
   *&#x2F;
  pub.strokeTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currStrokeTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Creates a new RGB or CMYK color and adds the new color to the document, or gets a color by name from the document
   *
   * @method color
   * @param  {String|Numbers} Get color: the color name. Create new color: R,G,B,name or C,M,Y,K,name or Grey,name. Name is always optional
   * @return {Color} found or new color
   *&#x2F;
  pub.color = function() {
    var newCol = null;
    var props = {};
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4];
    if (arguments.length === 1) {
      if (typeof a === &#x27;string&#x27;) {
        try {
          newCol = currentDoc().swatches.item(a);
          newCol.name;
        } catch (e) {
          error(&quot;Color doesn&#x27;t exist. &quot;+e);
        }
        return newCol;
      } else if (typeof a === &#x27;number&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [0,0,0,a];
        props.name = &quot;C=&quot;+0+&quot; M=&quot;+0+&quot; Y=&quot;+0+&quot; K=&quot;+a;
      } else {
        error(&quot;Color doesn&#x27;t exist.&quot;);
      }

    } else if (arguments.length === 2) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [0,0,0,a];
      props.name = b;

    } else if (arguments.length === 3) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.RGB;
      props.colorValue = [a,b,c];
      props.name = &quot;R=&quot;+a+&quot; G=&quot;+b+&quot; B=&quot;+c;

    } else if (arguments.length === 4) {
      if (typeof d === &#x27;string&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.RGB;
        props.colorValue = [a,b,c];
        props.name = d;
      } else {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [a,b,c,d];
        props.name = &quot;C=&quot;+a+&quot; M=&quot;+b+&quot; Y=&quot;+c+&quot; K=&quot;+d;
      }

    } else if (arguments.length === 5) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [a,b,c,d];
      props.name = e;

    } else {
      error(&quot;Wrong parameters. Use: &quot;
        + &quot;R,G,B,name or &quot;
        + &quot;C,M,Y,K,name. &quot;
        + &quot;Grey,name &quot;
        + &quot;Name is optional&quot;);
    }
    newCol = currentDoc().colors.add();
    newCol.properties = props;
    return newCol;
  };

  &#x2F;**
   * Calculates a color or colors between two color at a specific increment. 
   * The amt parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
   * N.B.: Both color must be either CMYK or RGB.
   * 
   * @method lerpColor
   * @param  {Color} c1   Input color 1
   * @param  {Color} c2   Input color 2
   * @param  {Number} amt The Amount to interpolate between the two colors
   * @return {Color} Interpolated color
   *&#x2F;
  pub.lerpColor = function (c1, c2, amt) {
    if (c1 instanceof Color &amp;&amp; c2 instanceof Color &amp;&amp; typeof amt === &#x27;number&#x27;) {
      if (c1.space === ColorSpace.CMYK &amp;&amp; c2.space === ColorSpace.CMYK) {
        var C1 = c1.colorValue[0];
        var M1 = c1.colorValue[1];
        var Y1 = c1.colorValue[2];
        var K1 = c1.colorValue[3];

        var C2 = c2.colorValue[0];
        var M2 = c2.colorValue[1];
        var Y2 = c2.colorValue[2];
        var K2 = c2.colorValue[3];

        var COut = Math.round( pub.lerp(C1,C2,amt) );
        var MOut = Math.round( pub.lerp(M1,M2,amt) );
        var YOut = Math.round( pub.lerp(Y1,Y2,amt) );
        var KOut = Math.round( pub.lerp(K1,K2,amt) );
        return pub.color(COut,MOut,YOut,KOut);

      } else if (c1.space === ColorSpace.RGB &amp;&amp; c2.space === ColorSpace.RGB) {
        var R1 = c1.colorValue[0];
        var G1 = c1.colorValue[1];
        var B1 = c1.colorValue[2];

        var R2 = c2.colorValue[0];
        var G2 = c2.colorValue[1];
        var B2 = c2.colorValue[2];

        var ROut = Math.round( pub.lerp(R1,R2,amt) );
        var GOut = Math.round( pub.lerp(G1,G2,amt) );
        var BOut = Math.round( pub.lerp(B1,B2,amt) );
        warning([ROut,GOut,BOut]);
        return pub.color(ROut,GOut,BOut);

      } else {
        error(&quot;Both color must be either CMYK or RGB.&quot;);
      }
    } else {
      error(&quot;Wrong parameters. Use: two colors (of the same type) and a number.&quot;);
    }
  };

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Typography
  
  &#x2F;**
   * Creates a text frame on the current layer on the current page in the current document. 
   * The text frame gets created in the position specified by the x and y parameters.
   * The default document font will be used unless a font is set with the textFont() function. 
   * The default document font size will be used unless a font size is set with the textSize() function. 
   * Change the color of the text with the fill() function.
   * The text displays in relation to the textAlign() and textYAlign() functions. 
   * The width and height parameters define a rectangular area.
   * 
   * @method text
   * @param  {String} txt The text content to set in the text frame.
   * @param  {Number} x   x-coordinate of text frame
   * @param  {Number} y   y-coordinate of text frame
   * @param  {Number} w   width of text frame
   * @param  {Number} h   height of text frame
   * @return {TextFrame}  The created text frame instance.
   *&#x2F;
  pub.text = function(txt, x, y, w, h) {
    var textFrame = currentPage().textFrames.add( currentLayer() );
    with (textFrame) {
      contents = txt;
      geometricBounds = [y, x, (y+h), (x+w)];
      textFramePreferences.verticalJustification = currYAlign;
    }
    pub.typo(textFrame, {
      &#x27;appliedFont&#x27;: currFont,
      &#x27;pointSize&#x27;: currFontSize,
      &#x27;fillColor&#x27;: currFillColor,
      &#x27;justification&#x27;: currAlign,
      &#x27;leading&#x27;: currLeading,
      &#x27;kerningValue&#x27;: currKerning,
      &#x27;tracking&#x27;: currTracking
    });

    &#x2F;&#x2F; TODO apply currMatrix to textFrame

    return textFrame;
  };

  &#x2F;**
   * Sets text properties to the given item. If the item is not an instance the text property can be set to, 
   * the property gets set to the direct descendants of the given item, e.g. all stories of a given document.
   * 
   * If no value is given and the given property is a string, the function acts as a getter and returns the 
   * corresponding value(s) in an array. This can either be an array containing the value of the concrete item 
   * (e.g. character) the values of the item&#x27;s descendants (e.g. paragraphs of given text frame).
   * 
   * @method typo
   * @param  {Document|Spread|Page|Layer|Story|TextFrame|Text} item  The object to apply the property to.
   * @param  {String|Object} property  The text property name of an object of key&#x2F;value property&#x2F;value pairs.
   *                                   If property is a string and no value is given, the function acts as getter.
   * @param  {String|Number} [value]   The value to apply to the property.
   * @return {String[]|Number[]}  The property value(s) if the function acts as getter or the items the property 
   *                              was assigned to.
   *&#x2F;
  pub.typo = function(item, property, value) {
    var result = [],
      actsAsGetter = typeof property === &#x27;string&#x27; &amp;&amp; (typeof value === undef || value === null),
      getOrSetProperties = function(textItem) {
        if (actsAsGetter) {
          result.push(textItem[prop]);
        } else {
          setProperties(textItem);
        }
      },
      setProperties = function(textItem) {
        if (typeof property === &#x27;string&#x27;) {
          result.push(textItem);
          setProperty(textItem, property, value);  
        } else if (typeof property === &#x27;object&#x27;) {
          result.push(textItem);
          for (var prop in property) {
            setProperty(textItem, prop, property[prop]);  
          }
        }
      },
      setProperty = function(textItem, prop, val) {
        textItem[prop] = val;
      };

    if (item instanceof Document ||
        item instanceof Spread ||
        item instanceof Page ||
        item instanceof Layer) {
      forEach(item.textFrames, function(textFrame) {
        pub.typo(textFrame, property, value);
      });
    } else if (item instanceof TextFrame) {
      forEach(item.paragraphs, function(para) {
        getOrSetProperties(para);
      });
    } else if (isText(item)) {
      getOrSetProperties(item);
    }
    return result;
  };

  &#x2F;**
   * Returns the current font and sets it if argument fontName is given.
   * 
   * @method textFont
   * @param  {String} [fontName] The name of the font to set. Font style can be separated with a tab, e.g. Helvetica\tBold
   * @return {String}            The name of the current font.
   *&#x2F;
  pub.textFont = function(fontName) {
    if (arguments.length === 1) {
      currFont = fontName;
    }
    return currFont;
  };

  &#x2F;**
   * Returns the current font size in points and sets it if argument pointSize is given.
   * 
   * @method textSize
   * @param  {Number} [pointSize] The size in points to set.
   * @return {Number}             The current point size.
   *&#x2F;
  pub.textSize = function(pointSize) {
    if (arguments.length === 1) {
      currFontSize = pointSize;
    }
    return currFontSize;
  };

  &#x2F;**
   * Sets the current horizontal and vertical text alignment.
   * 
   * @method textAlign
   * @param  {String} align    The horizontal text alignment to set. Must be one of the InDesign Justification enum values:
   *                           Justification.AWAY_FROM_BINDING_SIDE
   *                           Justification.CENTER_ALIGN
   *                           Justification.CENTER_JUSTIFIED
   *                           Justification.FULLY_JUSTIFIED
   *                           Justification.LEFT_ALIGN
   *                           Justification.LEFT_ALIGN
   *                           Justification.RIGHT_ALIGN
   *                           Justification.RIGHT_JUSTIFIED
   *                           Justification.TO_BINDING_SIDE
   * @param  {String} [yAlign] The vertical text alignment to set. Must be one of the InDesign VerticalJustification enum values:
   *                           VerticalJustification.BOTTOM_ALIGN
   *                           VerticalJustification.CENTER_ALIGN
   *                           VerticalJustification.JUSTIFY_ALIGN
   *                           VerticalJustification.TOP_ALIGN
   *&#x2F;
  pub.textAlign = function(align, yAlign) {
    currAlign = align;
    if (arguments.length === 2) currYAlign = yAlign;
  };

  &#x2F;**
   * Returns the spacing between lines of text in units of points and sets it if argument leading is given.
   * 
   * @method textLeading
   * @param  {Number|String} [leading] The spacing between lines of text in units of points or the default Indesign enum 
   *                                   value Leading.AUTO.
   * @return {Number|String}           The current leading.
   *&#x2F;
  pub.textLeading = function(leading) {
    if (arguments.length === 1) {
      currLeading = leading;
    }
    return currLeading;
  };

  &#x2F;**
   * Returns the current kerning and sets it if argument kerning is given.
   * 
   * @method textKerning
   * @param  {Number} [kerning] The value to set.
   * @return {Number}           The current kerning.
   *&#x2F;
  pub.textKerning = function(kerning) {
    if (arguments.length === 1) {
      currKerning = kerning;
    }
    return currKerning;
  };

  &#x2F;**
   * Returns the current tracking and sets it if argument tracking is given.
   * 
   * @method textTracking
   * @param  {Number} [tracking] The value to set.
   * @return {Number}            The current tracking.
   *&#x2F;
  pub.textTracking = function(tracking) {
    if (arguments.length === 1) {
      currTracking = tracking;
    }
    return currTracking;
  };

  var isText = function(obj) {
    return obj instanceof Character ||
           obj instanceof InsertionPoint ||
           obj instanceof Line ||
           obj instanceof Paragraph ||
           obj instanceof TextColumn ||
           obj instanceof TextStyleRange ||
           obj instanceof Word;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Image
  
  &#x2F;**
   * Adds an image to the document. If the image argument is given as a string the image file  must be in the document&#x27;s 
   * data directory which is in the same directory where the document is saved in. The image argument can also be a File 
   * instance which can be placed even before the document was saved.
   * The second argument can either be the x position of the frame to create or an instance of a rectangle, 
   * oval or polygon to place the image in.
   * If x and y positions are given and width and height are not given, the frame&#x27;s size gets set to the original image size.
   * 
   * @method image
   * @param  {String} img The image file name in the document&#x27;s data directory or a File instance
   * @param  {Number|Rectangle|Oval|Polygon} x The x position on the current page or the item instance to place the image in
   * @param  {Number} [y] The y position on the current page. Ignored if x is not a number.
   * @param  {Number} [w] The width of the rectangle to add the image to. Ignored if x is not a number.
   * @param  {Number} [h] The height of the rectangle to add the image to. Ignored if x is not a number.
   * @return {Rectangle|Oval|Polygon} The item instance the image was placed in.
   *&#x2F;
  pub.image = function(img, x, y, w, h) {
    var file = null;
    if (img instanceof File) {
      file = img;
    } else {
      var docPath = null;
      try {
        docPath = currentDoc().filePath;
      } catch (e) {
        error(&quot;The current document must be saved before an image located in the document&#x27;s data directory can be placed.&quot;);
      }
      file = new File(docPath.absoluteURI + &#x27;&#x2F;data&#x2F;&#x27; + img);
    }
    if (!file.exists) {
      error(&#x27;The file &quot;&#x27; + file + &#x27;&quot; does not exist.&#x27;);
    }

    var frame = null,
      fitOptions = null;
    if (x instanceof Rectangle ||
        x instanceof Oval ||
        x instanceof Polygon) {
      frame = x;
    } else {
      var width = 1,
          height = 1;
      if (currImageMode === pub.CORNERS) {
        width = w - x;
        height = h - y;
        fitOptions = FitOptions.contentToFrame;
      } else {
        if (w &amp;&amp; h) {
          width = w;
          height = h;
          fitOptions = FitOptions.contentToFrame;
        } else {
          fitOptions = FitOptions.frameToContent;
        }
      }
      
      frame = currentPage().rectangles.add({
        geometricBounds:[y, x, y + height, x + width]
      });
    }
    
    frame.place(file);

    if (fitOptions) {
      frame.fit(fitOptions);
    }

    if (currImageMode === pub.CENTER) {
      var bounds = frame.geometricBounds;
      var width = bounds[3] - bounds[1];
      var height = bounds[2] - bounds[0];
      frame.move(null, [-(width &#x2F; 2), -(height &#x2F; 2)]);
    }

    &#x2F;&#x2F; TODO apply currMatrix to frame
    
    return frame;
  };

  pub.imageMode = function(mode) {
    if (arguments.length === 0) return currImageMode;

    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER ) {
      currImageMode = mode;
    } else {
      error(&quot;Unsupported imageMode. Use: CORNER, CORNERS, CENTER.&quot;);
    }
    return currImageMode;
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Math
  
  var PVector = pub.PVector = function() {
    function PVector(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0
    }
    PVector.dist = function(v1, v2) {
      return v1.dist(v2)
    };
    PVector.dot = function(v1, v2) {
      return v1.dot(v2)
    };
    PVector.cross = function(v1, v2) {
      return v1.cross(v2)
    };
    PVector.angleBetween = function(v1, v2) {
      return Math.acos(v1.dot(v2) &#x2F; (v1.mag() * v2.mag()))
    };
    PVector.prototype = {
      set: function(v, y, z) {
        if (arguments.length === 1) this.set(v.x || v[0] || 0, v.y || v[1] || 0, v.z || v[2] || 0);
        else {
          this.x = v;
          this.y = y;
          this.z = z
        }
      },
      get: function() {
        return new PVector(this.x, this.y, this.z)
      },
      mag: function() {
        var x = this.x,
          y = this.y,
          z = this.z;
        return Math.sqrt(x * x + y * y + z * z)
      },
      add: function(v, y, z) {
        if (arguments.length === 1) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z
        } else {
          this.x += v;
          this.y += y;
          this.z += z
        }
      },
      sub: function(v, y, z) {
        if (arguments.length === 1) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z
        } else {
          this.x -= v;
          this.y -= y;
          this.z -= z
        }
      },
      mult: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x *= v;
          this.y *= v;
          this.z *= v
        } else {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z
        }
      },
      div: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x &#x2F;= v;
          this.y &#x2F;= v;
          this.z &#x2F;= v
        } else {
          this.x &#x2F;= v.x;
          this.y &#x2F;= v.y;
          this.z &#x2F;= v.z
        }
      },
      dist: function(v) {
        var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz)
      },
      dot: function(v, y, z) {
        if (arguments.length === 1) return this.x * v.x + this.y * v.y + this.z * v.z;
        return this.x * v + this.y * y + this.z * z
      },
      cross: function(v) {
        var x = this.x,
          y = this.y,
          z = this.z;
        return new PVector(y * v.z - v.y * z, z * v.x - v.z * x, x * v.y - v.x * y)
      },
      normalize: function() {
        var m = this.mag();
        if (m &gt; 0) this.div(m)
      },
      limit: function(high) {
        if (this.mag() &gt; high) {
          this.normalize();
          this.mult(high)
        }
      },
      heading2D: function() {
        return -Math.atan2(-this.y, this.x)
      },
      toString: function() {
        return &quot;[&quot; + this.x + &quot;, &quot; + this.y + &quot;, &quot; + this.z + &quot;]&quot;
      },
      array: function() {
        return [this.x, this.y, this.z]
      }
    };

    function createPVectorMethod(method) {
      return function(v1, v2) {
        var v = v1.get();
        v[method](v2);
        return v
      }
    }
    for (var method in PVector.prototype) if (PVector.prototype.hasOwnProperty(method) &amp;&amp; !PVector.hasOwnProperty(method)) PVector[method] = createPVectorMethod(method);
    return PVector
  }();
  

  &#x2F;&#x2F; -- Calculation --
  pub.abs = Math.abs;

  pub.ceil = Math.ceil;

  pub.constrain = function(aNumber, aMin, aMax) {
    return aNumber &gt; aMax ? aMax : aNumber &lt; aMin ? aMin : aNumber
  };

  pub.dist = function() {
    var dx, dy, dz;
    if (arguments.length === 4) {
      dx = arguments[0] - arguments[2];
      dy = arguments[1] - arguments[3];
      return Math.sqrt(dx * dx + dy * dy)
    }
  };

  pub.exp = Math.exp;

  pub.floor = Math.floor;

  pub.lerp = function(value1, value2, amt) {
    return (value2 - value1) * amt + value1
  };

  pub.log = Math.log;

  pub.mag = function(a, b, c) {
    if (c) return Math.sqrt(a * a + b * b + c * c);
    return Math.sqrt(a * a + b * b)
  };

  pub.map = function(value, istart, istop, ostart, ostop) {
    return ostart + (ostop - ostart) * ((value - istart) &#x2F; (istop - istart))
  };

  pub.max = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[1] : arguments[0];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var max = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (max &lt; numbers[i]) max = numbers[i];
    return max
  };

  pub.min = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[0] : arguments[1];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var min = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (min &gt; numbers[i]) min = numbers[i];
    return min
  };

  pub.norm = function(aNumber, low, high) {
    return (aNumber - low) &#x2F; (high - low)
  };

  pub.pow = Math.pow;

  pub.round = Math.round;

  pub.sq = function(aNumber) {
    return aNumber * aNumber
  };
  

  &#x2F;&#x2F; -- Trigonometry -- 
  pub.sqrt = Math.sqrt;
  pub.acos = Math.acos;
  pub.asin = Math.asin;
  pub.atan = Math.atan;
  pub.atan2 = Math.atan2;
  pub.cos = Math.cos;

  pub.degrees = function(aAngle) {
    return aAngle * 180 &#x2F; Math.PI
  };

  pub.radians = function(aAngle) {
    return aAngle &#x2F; 180 * Math.PI
  };

  pub.sin = Math.sin;
  pub.tan = Math.tan;

  &#x2F;&#x2F; -- Random --
  var currentRandom = Math.random;
  pub.random = function() {
    if (arguments.length === 0) return currentRandom();
    if (arguments.length === 1) return currentRandom() * arguments[0];
    var aMin = arguments[0],
      aMax = arguments[1];
    return currentRandom() * (aMax - aMin) + aMin
  };

  function Marsaglia(i1, i2) {
    var z = i1 || 362436069,
      w = i2 || 521288629;
    var nextInt = function() {
      z = 36969 * (z &amp; 65535) + (z &gt;&gt;&gt; 16) &amp; 4294967295;
      w = 18E3 * (w &amp; 65535) + (w &gt;&gt;&gt; 16) &amp; 4294967295;
      return ((z &amp; 65535) &lt;&lt; 16 | w &amp; 65535) &amp; 4294967295
    };
    this.nextDouble = function() {
      var i = nextInt() &#x2F; 4294967296;
      return i &lt; 0 ? 1 + i : i
    };
    this.nextInt = nextInt
  }
  Marsaglia.createRandomized = function() {
    var now = new Date;
    return new Marsaglia(now &#x2F; 6E4 &amp; 4294967295, now &amp; 4294967295)
  };

  pub.randomSeed = function(seed) {
    currentRandom = (new Marsaglia(seed)).nextDouble
  };

  pub.Random = function(seed) {
    var haveNextNextGaussian = false,
      nextNextGaussian, random;
    this.nextGaussian = function() {
      if (haveNextNextGaussian) {
        haveNextNextGaussian = false;
        return nextNextGaussian
      }
      var v1, v2, s;
      do {
        v1 = 2 * random() - 1;
        v2 = 2 * random() - 1;
        s = v1 * v1 + v2 * v2
      } while (s &gt;= 1 || s === 0);
      var multiplier = Math.sqrt(-2 * Math.log(s) &#x2F; s);
      nextNextGaussian = v2 * multiplier;
      haveNextNextGaussian = true;
      return v1 * multiplier
    };
    random = seed === undef ? Math.random : (new Marsaglia(seed)).nextDouble
  };

  function PerlinNoise(seed) {
    var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();
    var i, j;
    var perm = new Uint8Array(512);
    for (i = 0; i &lt; 256; ++i) perm[i] = i;
    for (i = 0; i &lt; 256; ++i) {
      var t = perm[j = rnd.nextInt() &amp; 255];
      perm[j] = perm[i];
      perm[i] = t
    }
    for (i = 0; i &lt; 256; ++i) perm[i + 256] = perm[i];

    function grad3d(i, x, y, z) {
      var h = i &amp; 15;
      var u = h &lt; 8 ? x : y,
      v = h &lt; 4 ? y : h === 12 || h === 14 ? x : z;
      return ((h &amp; 1) === 0 ? u : -u) + ((h &amp; 2) === 0 ? v : -v)
    }
    function grad2d(i, x, y) {
      var v = (i &amp; 1) === 0 ? x : y;
      return (i &amp; 2) === 0 ? -v : v
    }
    function grad1d(i, x) {
      return (i &amp; 1) === 0 ? -x : x
    }
    function lerp(t, a, b) {
      return a + t * (b - a)
    }
    this.noise3d = function(x, y, z) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255,
        Z = Math.floor(z) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y,
        fz = (3 - 2 * z) * z * z;
      var p0 = perm[X] + Y,
        p00 = perm[p0] + Z,
        p01 = perm[p0 + 1] + Z,
        p1 = perm[X + 1] + Y,
        p10 = perm[p1] + Z,
        p11 = perm[p1 + 1] + Z;
      return lerp(fz, lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)), lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))), lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)), lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))))
    };
    this.noise2d = function(x, y) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y;
      var p0 = perm[X] + Y,
        p1 = perm[X + 1] + Y;
      return lerp(fy, lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)), lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1)))
    };
    this.noise1d = function(x) {
      var X = Math.floor(x) &amp; 255;
      x -= Math.floor(x);
      var fx = (3 - 2 * x) * x * x;
      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X + 1], x - 1))
    }
  }
  var noiseProfile = {
    generator: undef,
    octaves: 4,
    fallout: 0.5,
    seed: undef
  };
  pub.noise = function(x, y, z) {
    if (noiseProfile.generator === undef) noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
    var generator = noiseProfile.generator;
    var effect = 1,
      k = 1,
      sum = 0;
    for (var i = 0; i &lt; noiseProfile.octaves; ++i) {
      effect *= noiseProfile.fallout;
      switch (arguments.length) {
      case 1:
        sum += effect * (1 + generator.noise1d(k * x)) &#x2F; 2;
        break;
      case 2:
        sum += effect * (1 + generator.noise2d(k * x, k * y)) &#x2F; 2;
        break;
      case 3:
        sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) &#x2F; 2;
        break
      }
      k *= 2
    }
    return sum
  };
  pub.noiseDetail = function(octaves, fallout) {
    noiseProfile.octaves = octaves;
    if (fallout !== undef) noiseProfile.fallout = fallout
  };
  pub.noiseSeed = function(seed) {
    noiseProfile.seed = seed;
    noiseProfile.generator = undef
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Input
  
  pub.year = function() {
    return (new Date).getFullYear()
  };
  pub.month = function() {
    return (new Date).getMonth() + 1
  };
  pub.day = function() {
    return (new Date).getDate()
  };
  pub.hour = function() {
    return (new Date).getHours()
  };
  pub.minute = function() {
    return (new Date).getMinutes()
  };
  pub.second = function() {
    return (new Date).getSeconds()
  };
  pub.millis = function() {
    return Date.now() - start
  };

  &#x2F;**
   * Returns items tagged with the given label in the InDesign Script Label pane (Window -&gt; Utilities -&gt; Script Label).
   * 
   * @method findByLabel
   * @param  {String} label The label identifier
   * @return {PageItem[]} Array of concrete PageItem instances, e.g. TextFrame or SplineItem. 
   *&#x2F;
  pub.findByLabel = function(label) {
    var result = [];
    var doc = currentDoc();
    for (var i = 0, len = doc.pageItems.length; i &lt; len; i++) {
      var pageItem = doc.pageItems[i];
      if (pageItem.label === label) {
        &#x2F;&#x2F; push pageItem&#x27;s 1st element to get the concrete PageItem instance, e.g. a TextFrame 
        result.push(pageItem.getElements()[0]);
      }
    }
    return result;
  };

  &#x2F;**
   * Returns the currently selected object(s). 
   * @return {Object[]} Array of selected object(s).
   *&#x2F;
  pub.selection = function() {
    var selection = app.selection;
    if (!isArray(selection)) {
      selection = [selection];
    }
    return selection;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Output
  
  pub.println = function(msg) {
    $.writeln(msg);
  };

  pub.print = function(msg) {
    $.write(msg);
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Transform
  
  var printMatrixHelper = function(elements) {
    var big = 0;
    for (var i = 0; i &lt; elements.length; i++) if (i !== 0) big = Math.max(big, Math.abs(elements[i]));
    else big = Math.abs(elements[i]);
    var digits = (big + &quot;&quot;).indexOf(&quot;.&quot;);
    if (digits === 0) digits = 1;
    else if (digits === -1) digits = (big + &quot;&quot;).length;
    return digits
  };

  var PMatrix2D = pub.PMatrix2D = function() {
    if (arguments.length === 0) this.reset();
    else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) this.set(arguments[0].array());
    else if (arguments.length === 6) this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5])
  };
  PMatrix2D.prototype = {
    set: function() {
      if (arguments.length === 6) {
        var a = arguments;
        this.set([a[0], a[1], a[2], a[3], a[4], a[5]])
      } else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) this.elements = arguments[0].array();
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) this.elements = arguments[0].slice()
    },
    get: function() {
      var outgoing = new PMatrix2D;
      outgoing.set(this.elements);
      return outgoing
    },
    reset: function() {
      this.set([1, 0, 0, 0, 1, 0])
    },
    array: function array() {
      return this.elements.slice()
    },
    adobeMatrix: function array() {
      return [this.elements[0], 
              this.elements[3],  
              this.elements[1], 
              this.elements[4],
              this.elements[2], 
              this.elements[5]];
    },
    translate: function(tx, ty) {
      this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
      this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5]
    },
    invTranslate: function(tx, ty) {
      this.translate(-tx, -ty)
    },
    transpose: function() {},
    mult: function(source, target) {
      var x, y;
      if (source instanceof PVector) {
        x = source.x;
        y = source.y;
        if (!target) target = new PVector
      } else if (source instanceof Array) {
        x = source[0];
        y = source[1];
        if (!target) target = []
      }
      if (target instanceof Array) {
        target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
        target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5]
      } else if (target instanceof PVector) {
        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
        target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
        target.z = 0
      }
      return target
    },
    multX: function(x, y) {
      return x * this.elements[0] + y * this.elements[1] + this.elements[2]
    },
    multY: function(x, y) {
      return x * this.elements[3] + y * this.elements[4] + this.elements[5]
    },
    &#x2F;*
    &#x2F;&#x2F; BUG, seems to be buggy in processing.js, and i am not clever enough to figure it out
    shearX: function(angle) {
      this.apply(1, 0, 1, Math.tan(angle), 0, 0)
    },
    shearY: function(angle) {
      this.apply(1, 0, 1, 0, Math.tan(angle), 0)
    },*&#x2F;
    determinant: function() {
      return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]
    },
    invert: function() {
      var d = this.determinant();
      if (Math.abs(d) &gt; -2147483648) {
        var old00 = this.elements[0];
        var old01 = this.elements[1];
        var old02 = this.elements[2];
        var old10 = this.elements[3];
        var old11 = this.elements[4];
        var old12 = this.elements[5];
        this.elements[0] = old11 &#x2F; d;
        this.elements[3] = -old10 &#x2F; d;
        this.elements[1] = -old01 &#x2F; d;
        this.elements[4] = old00 &#x2F; d;
        this.elements[2] = (old01 * old12 - old11 * old02) &#x2F; d;
        this.elements[5] = (old10 * old02 - old00 * old12) &#x2F; d;
        return true
      }
      return false
    },
    scale: function(sx, sy) {
      if (sx &amp;&amp; !sy) sy = sx;
      if (sx &amp;&amp; sy) {
        this.elements[0] *= sx;
        this.elements[1] *= sy;
        this.elements[3] *= sx;
        this.elements[4] *= sy
      }
    },
    invScale: function(sx, sy) {
      if (sx &amp;&amp; !sy) sy = sx;
      this.scale(1 &#x2F; sx, 1 &#x2F; sy)
    },
    apply: function() {
      var source;
      if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) source = arguments[0].array();
      else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) source = arguments[0];
      var result = [0, 0, this.elements[2], 0, 0, this.elements[5]];
      var e = 0;
      for (var row = 0; row &lt; 2; row++) for (var col = 0; col &lt; 3; col++, e++) result[e] += this.elements[row * 3 + 0] * source[col + 0] + this.elements[row * 3 + 1] * source[col + 3];
      this.elements = result.slice()
    },
    preApply: function() {
      var source;
      if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) source = arguments[0].array();
      else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) source = arguments[0];
      var result = [0, 0, source[2], 0, 0, source[5]];
      result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];
      result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];
      result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];
      result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];
      result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];
      result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];
      this.elements = result.slice()
    },
    rotate: function(angle) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var temp1 = this.elements[0];
      var temp2 = this.elements[1];
      this.elements[0] = c * temp1 + s * temp2;
      this.elements[1] = -s * temp1 + c * temp2;
      temp1 = this.elements[3];
      temp2 = this.elements[4];
      this.elements[3] = c * temp1 + s * temp2;
      this.elements[4] = -s * temp1 + c * temp2
    },
    rotateZ: function(angle) {
      this.rotate(angle)
    },
    invRotateZ: function(angle) {
      this.rotateZ(angle - Math.PI)
    },
    print: function() {
      var digits = printMatrixHelper(this.elements);
      var output = &quot;&quot; + pub.nfs(this.elements[0], digits, 4) + &quot; &quot; + pub.nfs(this.elements[1], digits, 4) + &quot; &quot; + pub.nfs(this.elements[2], digits, 4) + &quot;\n&quot; + pub.nfs(this.elements[3], digits, 4) + &quot; &quot; + pub.nfs(this.elements[4], digits, 4) + &quot; &quot; + pub.nfs(this.elements[5], digits, 4) + &quot;\n\n&quot;;
      pub.println(output)
    }
  };

  pub.applyMatrix = function (matrix) {
    currMatrix.apply(matrix);
  };

  pub.popMatrix = function (argument) {
    if (matrixStack.length &gt; 0) {
      currMatrix.set( matrixStack.pop() );
    } else {
      error(&quot;Missing a pushMatrix() to go with that popMatrix()&quot;);
    }
  };

  pub.printMatrix = function (argument) {
    currMatrix.print();
  };

  pub.pushMatrix = function (argument) {
    matrixStack.push( currMatrix.array() );
  };

  pub.resetMatrix = function (argument) {
    matrixStack = [];
    currMatrix = new PMatrix2D();
  };

  pub.rotate = function (angle) {
    currMatrix.rotate(angle);
  };

  pub.scale = function (scaleX,scaleY) {
    currMatrix.scale(scaleX,scaleY);
  };

  pub.translate = function (tx,ty) {
    currMatrix.translate(tx,ty);
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; execution
  
  &#x2F;**
   * Run the sketch! Has to be called in every sketch a the very end of the code.
   *
   * @method go
   *&#x2F; 
  pub.go = function() {
    currentDoc();
    runUserScript();
  }


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; all private from here

  var init = function() {
    glob.b = pub;

    welcome();

    &#x2F;&#x2F; -- init internal state vars --
    currStrokeWeight = 1;
    currStrokeTint = 100;
    currFillTint = 100;
  };

  var runUserScript = function() {
    app.doScript(function() {
      if (typeof glob.setup === &#x27;function&#x27;) {
        glob.setup();
      }
      if (typeof glob.draw === &#x27;function&#x27;) {
        glob.draw();
      }      
    }, ScriptLanguage.javascript, undef, UndoModes.entireScript);
  };

  var welcome = function() {
    $.writeln(&quot;basil.js &quot;
        + pub.VERSION
        + &quot; &quot;
        + &quot;infos, feedback @ http:&#x2F;&#x2F;basiljs.ch&quot;);
  };
  
  var currentDoc = function() {
    if (!currDoc) {
      var doc = null;
      try {
        doc = app.activeDocument;  
      } catch(e) {
        doc = app.documents.add();
      }
      setCurrDoc(doc);
    }
    return currDoc;
  };

  var setCurrDoc = function(doc) {
    resetCurrDoc();
    currDoc = doc;
    &#x2F;&#x2F; -- setup document --
    currDoc.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;
    currFont = currDoc.textDefaults.appliedFont.name;
    currFontSize = currDoc.textDefaults.pointSize;
    currAlign = currDoc.textDefaults.justification;
    currLeading = currDoc.textDefaults.leading;
    currKerning = 0;
    currTracking = currDoc.textDefaults.tracking;
    pub.units(pub.PT);
    updatePublicPageSizeVars();
  };

  var resetCurrDoc = function() {
    &#x2F;&#x2F; resets doc and doc specific vars
    currDoc = null;
    currPage = null;
    currLayer = null;
    currFillColor = &quot;Black&quot;;
    noneSwatchColor = &quot;None&quot;;
    currStrokeColor = &quot;Black&quot;;
    currRectMode = pub.CORNER;
    currEllipseMode = pub.CENTER;
    currYAlign = VerticalJustification.TOP_ALIGN;
    start = Date.now();
    currFont = null;
    currImageMode = pub.CORNER;
    pub.resetMatrix();
  };

  var currentLayer = function() {
    if (!currLayer) {
      currentDoc();
      currLayer = app.activeDocument.activeLayer;
    }
    return currLayer;
  };
  
  var currentPage = function() {
    if (!currPage) {
      currentDoc();
      currPage = app.activeWindow.activePage;
    }
    return currPage;
  };

  var updatePublicPageSizeVars = function () {
    var pageBounds = currentPage().bounds; &#x2F;&#x2F; [y1, x1, y2, x2]
    var w = pageBounds[3] - pageBounds[1];
    var h = pageBounds[2] - pageBounds[0];
    pub.width = w;
    pub.height = h;
  };

  var isArray = function(obj) {
    return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;
  };

  var error = function(msg) {
    $.writeln(ERROR_PREFIX + msg);
    throw ERROR_PREFIX + msg;
  };

  var warning = function(msg) {
    $.writeln(WARNING_PREFIX + msg);
  };
  
  init();
  
})(this, app);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
