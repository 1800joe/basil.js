<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>basil.js - basil.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;basiljs.ch&#x2F;basil2.jpg" title="basil.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/b.html">b</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: basil.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
#target &quot;InDesign&quot;;

(function(glob, app, undef) {
  &#x2F;**
   * @class b
   * @static
   *&#x2F;
  var pub = {};

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; constants
  pub.VERSION = &quot;0.1&quot;;
  pub.PT = &quot;pt&quot;;
  pub.PX = &quot;px&quot;;
  pub.CM = &quot;cm&quot;;
  pub.MM = &quot;mm&quot;;
  var ERROR_PREFIX = &quot;### Basil Error -&gt; &quot;,
    WARNING_PREFIX = &quot;### Basil Warning -&gt; &quot;;

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; public vars
  
  &#x2F;**
   * @property width {Number}
   *&#x2F;
  pub.width = null;

  &#x2F;**
   * @property height {Number}
   *&#x2F;
  pub.height = null;

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; private vars
  var currDoc = null,
    currPage = null,
    currLayer = null,
    currUnits = null,
    currColorMode = null,
    currFillColor = null,
    currNoFillColor = null,
    currStrokeColor = null,
    currStrokeTint = null,
    currFillTint = null,
    currStrokeWeight = null;

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; global functions

  if (!glob.forEach) {
    glob.forEach = function(collection, cb) {
      for (var i = 0, len = collection.length; i &lt; len; i++) {
        cb(collection[i],i);
      }
    };
  }
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Environment
  
  &#x2F;**
   * Sets or possibly creates the current document and returns it. 
   * If the param doc is not given the current document gets set to the active document 
   * in the application. If no document at all is open, a new document gets created.
   * 
   * @method doc
   * @param  {Document} [doc] The document to set the current document to.
   * @return {Document} The current document instance.
   *&#x2F;
  pub.doc = function(doc) {
    if (doc instanceof Document) {
      setCurrDoc(doc);
    }
    return currentDoc();
  };

  &#x2F;**
   * Closes the current document.
   * 
   * @method close
   * @param  {SaveOptions} [saveOptions] The indesign SaveOptions constant
   * @param  {File} [file] The indesign file instance to save the document to
   *&#x2F;
  pub.close = function(saveOptions, file) {
    var doc = currentDoc();
    if (doc) {
      doc.close(saveOptions, file);
      resetCurrDoc();
    }
  }

  &#x2F;**
   * Returns the current page and possibly sets it.
   * 
   * @method page
   * @param  {Page|Number} [page] The page or page index to set the current page to.
   * @return {Page} The current page instance.
   *&#x2F;
  pub.page = function(page) {
    if (page instanceof Page) {
      currPage = page;
    } else if (typeof page === &#x27;number&#x27;) {
      var tempPage = currentDoc().pages[page];
      try {
        tempPage.id;
      } catch (e) {
        error(&#x27;Page &#x27; + page + &#x27; does not exist.&#x27;);
      }
      currPage = tempPage;
    }
    updatePublicPageSizeVars();
    return currentPage();
  };

  &#x2F;**
   * Returns the current layer and possibly sets it.
   * 
   * @method layer
   * @param  {Layer|String} [layer] The layer or layer name to set the current layer to.
   * @return {Layer} The current page instance.
   *&#x2F;
  pub.layer = function(layer) {
    if (layer instanceof Layer) {
      currLayer = layer;
    } else if (typeof layer === &#x27;string&#x27;) {
      var layers = currentDoc().layers;
      currLayer = layers.item(layer);
      if (!currLayer.isValid) {
        currLayer = layers.add({name: layer});
      }
    }
    return currentLayer();
  };

  &#x2F;**
   * Sets the units of the document (like right clicking the rulers).
   * 
   * @method units
   * @param  {Constant} [units] supported: PT, PX, CM or MM
   * @return {Constant} current unit setting
   *&#x2F;
  pub.units = function (units) {
    if (!units) return currUnits;

    if (units === pub.CM || 
        units === pub.MM ||
        units === pub.PT || 
        units === pub.PX ) {
      var unitType = null;
      if      (units === pub.CM) unitType = MeasurementUnits.centimeters;
      else if (units === pub.MM) unitType = MeasurementUnits.millimeters;
      else if (units === pub.PT) unitType = MeasurementUnits.points;
      else if (units === pub.PX) unitType = MeasurementUnits.pixels;
      var doc = currentDoc(); 
      with (doc.viewPreferences){
        &#x2F;&#x2F;* MeasurementUnits.agates
        &#x2F;&#x2F;* MeasurementUnits.picas
        &#x2F;&#x2F;* MeasurementUnits.points
        &#x2F;&#x2F;* MeasurementUnits.inches
        &#x2F;&#x2F;* MeasurementUnits.inchesDecimal
        &#x2F;&#x2F;* MeasurementUnits.millimeters
        &#x2F;&#x2F;* MeasurementUnits.centimeters
        &#x2F;&#x2F;* MeasurementUnits.ciceros
        horizontalMeasurementUnits = unitType; 
        verticalMeasurementUnits = unitType;
      }
      currUnits = units;
    } else {
      error(&quot;Not supported unit&quot;);
    }
    return currUnits;
  }

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Shape
  
  &#x2F;**
   * Draws an ellipse (oval) in the display window. An ellipse with an equal &lt;b&gt;width&lt;&#x2F;b&gt; and &lt;b&gt;height&lt;&#x2F;b&gt; is a circle.
   * The first two parameters set the location, the third sets the width, and the fourth sets the height.
   * @param  {Number} x Location x-value
   * @param  {Number} y Location y-value
   * @param  {Number} w Width
   * @param  {Number} h Height
   * @return {Oval} new oval (in Adobe Scripting the type is Oval, not ellipse)
   *&#x2F;
  pub.ellipse = function(x, y, w, h){
    var ellipseBounds = [0,0,0,0];
    ellipseBounds[0] = y;
    ellipseBounds[1] = x;
    ellipseBounds[2] = y+h;
    ellipseBounds[3] = x+w;
    var ovals = app.activeWindow.activeSpread.ovals;
    var newOval = ovals.add( currentLayer() );
    with(newOval) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint; 
      fillColor = currFillColor;
      fillTint = currFillTint; 
      strokeColor = currStrokeColor;  
      geometricBounds = ellipseBounds;
    } 
    return newOval;
  };

  &#x2F;**
   * Draws a line (a direct path between two points) to the screen.
   * @param  {Number} [x1] Point A x-value
   * @param  {Number} [y1] Point A y-value
   * @param  {Number} [x2] Point B x-value
   * @param  {Number} [y2] Point B y-value
   * @return {Rectangle} new rectangle
   *&#x2F;
  pub.line = function(x1, y1, x2, y2) {
    var lines = currentPage().graphicLines;
    var lineBounds = [];
    lineBounds[0] = y1;
    lineBounds[1] = x1;
    lineBounds[2] = y2;
    lineBounds[3] = x2;
    
    var newLine = lines.add( currentLayer() );
    with(newLine) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint; 
      fillColor = currFillColor;
      fillTint = currFillTint; 
      strokeColor = currStrokeColor; 
      geometricBounds = lineBounds;
    }

    var scaleX = 1.0, scaleY = 1.0;
    if (x2 &lt; x1) scaleX = -1.0;
    if (y2 &lt; y1) scaleY = -1.0;
    var scaleMatrix = app.transformationMatrices.add({&#x27;horizontalScaleFactor&#x27;: scaleX, &#x27;verticalScaleFactor&#x27;: scaleY});
    newLine.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                   AnchorPoint.CENTER_ANCHOR,
                   scaleMatrix);
    return newLine;
  };

  &#x2F;**
   * Draws a rectangle to the page.
   * @param  {Number} [x] Position X
   * @param  {Number} [y] Position Y
   * @param  {Number} [w] Width
   * @param  {Number} [h] Height
   * @return {Rectangle}   new Rectangle
   *&#x2F;
  pub.rect = function(x, y, w, h){
    var rectBounds = [];
    rectBounds[0] = y;
    rectBounds[1] = x;
    rectBounds[2] = (y+h);
    rectBounds[3] = (x+w);
    var newRect = currentPage().rectangles.add( currentLayer() );
    with(newRect) {
      geometricBounds = rectBounds;
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      strokeColor = currStrokeColor;
    }
    return newRect;
  };


  pub.strokeWeight = function (weight) {
    if (typeof weight === &#x27;string&#x27; || typeof weight === &#x27;number&#x27;) {
      currStrokeWeight = weight;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };
  


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Color
  
  pub.fill = function (fillColor) {
    if (fillColor instanceof Color || fillColor instanceof Swatch) {
      currFillColor = fillColor;
    } else {
      currFillColor = pub.color(arguments);
    }
  };

  pub.noFill = function () {
    currFillColor = currNoFillColor;
  };

  pub.stroke = function (strokeColor) {
    if (strokeColor instanceof Color || strokeColor instanceof Swatch) {
      currStrokeColor = strokeColor;
    } else {
      currStrokeColor = pub.color(arguments);
    }
  };

  pub.fillTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currFillTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  pub.strokeTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currStrokeTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Creates a new RGB or CMYK color and adds the new color to the document,
   * or gets a color by name from the document
   * @param  {Numbers|String} Get color: name. Create new color: R,G,B,name or C,M,Y,K,name or Grey,name. Name is always optional
   * @return {Color} new color
   *&#x2F;
  pub.color = function() {
    var newCol = null;
    var props = {};
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4];
    if (arguments.length === 1) {
      if (typeof a === &#x27;string&#x27;) {
        try {
          newCol = currentDoc().swatches.item(a);
          newCol.name;
        } catch (e) {
          error(&quot;Color doesn&#x27;t exist. &quot;+e);
        }
        return newCol;
      } else if (typeof a === &#x27;number&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [0,0,0,a];
        props.name = &quot;C=&quot;+0+&quot; M=&quot;+0+&quot; Y=&quot;+0+&quot; K=&quot;+a;
      } else {
        error(&quot;Color doesn&#x27;t exist.&quot;);
      }

    } else if (arguments.length === 2) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [0,0,0,a];
      props.name = b;

    } else if (arguments.length === 3) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.RGB;
      props.colorValue = [a,b,c];
      props.name = &quot;R=&quot;+a+&quot; G=&quot;+b+&quot; B=&quot;+c;

    } else if (arguments.length === 4) {
      if (typeof d === &#x27;string&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.RGB;
        props.colorValue = [a,b,c];
        props.name = d;
      } else {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [a,b,c,d];
        props.name = &quot;C=&quot;+a+&quot; M=&quot;+b+&quot; Y=&quot;+c+&quot; K=&quot;+d;
      }

    } else if (arguments.length === 5) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [a,b,c,d];
      props.name = e;

    } else {
      error(&quot;Wrong parameters. Use: &quot;
        + &quot;R,G,B,name or &quot;
        + &quot;C,M,Y,K,name. &quot;
        + &quot;Grey,name &quot;
        + &quot;Name is optional&quot;);
    }
    newCol = currentDoc().colors.add();
    newCol.properties = props;
    return newCol;
  };

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Typography
  
  &#x2F;**
   * Creates a text frame on the current layer on the current page in the current document. 
   * The text frame gets created in the position specified by the x and y parameters.
   * The default document font will be used unless a font is set with the textFont() function. 
   * Change the color of the text with the fill() function.
   * The text displays in relation to the textAlign() function, which gives the option to draw to the left, 
   * right, and center of the coordinates. 
   * The width and height parameters define a rectangular area.
   * 
   * @method text
   * @param  {String} txt The text content to set in the text frame.
   * @param  {Number} x   x-coordinate of text frame
   * @param  {Number} y   y-coordinate of text frame
   * @param  {Number} w   width of text frame
   * @param  {Number} h   height of text frame
   * @return {TextFrame}  The created text frame instance.
   *&#x2F;
  pub.text = function(txt, x, y, w, h) {
    var textFrame = currentPage().textFrames.add( currentLayer() );
    with (textFrame) {
      contents = txt;
      geometricBounds = [y, x, (y+h), (x+w)];
      &#x2F;* TODO tbd, what has to be set, e.g. fillColor is balck by default
      strokeWeight = currStrokeWeight;
      strokeColor = currStrokeColor;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      &#x2F;&#x2F;align
      *&#x2F;
    }
    return textFrame;
  };

  &#x2F;**
   * Sets text properties to the given item. If the item is not an instance the text property can be set to, 
   * the property gets set to the direct descendants of the given item, e.g. all stories of a given document.
   * 
   * If no value is given and the given property is a string, the function acts as a getter and returns the 
   * corresponding value(s) in an array. This can either be an array containing the value of the concrete item 
   * (e.g. character) the values of the item&#x27;s descendants (e.g. paragraphs of given text frame).
   * 
   * @method typo
   * @param  {Document|Spread|Page|Layer|Story|TextFrame|Text} item  The object to apply the property to.
   * @param  {String|Object} property  The text property name of an object of key&#x2F;value property&#x2F;value pairs.
   *                                   If property is a string and no value is given, the function acts as getter.
   * @param  {String|Number} [value]   The value to apply to the property.
   * @return {String[]|Number[]}  The property value(s) if the function acts as getter or the items the property 
   *                              was assigned to.
   *&#x2F;
  pub.typo = function(item, property, value) {
    var result = [],
      actsAsGetter = typeof property === &#x27;string&#x27; &amp;&amp; (typeof value === &#x27;undefined&#x27; || value === null),
      getOrSetProperties = function(textItem) {
        if (actsAsGetter) {
          result.push(textItem[prop]);
        } else {
          setProperties(textItem);
        }
      },
      setProperties = function(textItem) {
        if (typeof property === &#x27;string&#x27;) {
          result.push(textItem);
          setProperty(textItem, property, value);  
        } else if (typeof property === &#x27;object&#x27;) {
          result.push(textItem);
          for (var prop in property) {
            setProperty(textItem, prop, property[prop]);  
          }
        }
      },
      setProperty = function(textItem, prop, val) {
        textItem[prop] = val;
      };

    if (item instanceof Document ||
        item instanceof Spread ||
        item instanceof Page ||
        item instanceof Layer) {
      forEach(item.textFrames, function(textFrame) {
        pub.typo(textFrame, property, value);
      });
    } else if (item instanceof TextFrame) {
      forEach(item.paragraphs, function(para) {
        getOrSetProperties(para);
      });
    } else if (item instanceof Character ||
               item instanceof InsertionPoint ||
               item instanceof Line ||
               item instanceof Paragraph ||
               item instanceof TextColumn ||
               item instanceof TextStyleRange ||
               item instanceof Word) 
    {
      getOrSetProperties(item);
    }
    return result;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Image
  
  &#x2F;**
   * Adds an image to the document. The image file must be in the &quot;[indesign\_scripts\_path]&#x2F;data&quot; directory 
   * to load correctly (e.g. &quot;~&#x2F;Library&#x2F;Preferences&#x2F;Adobe InDesign&#x2F;Version 7.5&#x2F;en_GB&#x2F;Scripts&#x2F;Scripts Panel&#x2F;data&quot;).
   * The second argument can either be the x position of the frame to create or an instance of a rectangle, 
   * oval or polygon to place the image in.
   * If x and y positions are given and width and height are not given, the frame&#x27;s size gets set to the original image size.
   * 
   * @method image
   * @param  {String} img The image file name in the &quot;[indesign\_scripts\_path]&#x2F;data&quot; directory
   * @param  {Number|Rectangle|Oval|Polygon} itemOrX The x position on the current page or the item instance to place the image in
   * @param  {Number} [y] The y position on the current page. Ignored if itemOrX is not a number.
   * @param  {Number} [w] The width of the rectangle to add the image to. Ignored if itemOrX is not a number.
   * @param  {Number} [h] The height of the rectangle to add the image to. Ignored if itemOrX is not a number.
   * @return {Rectangle|Oval|Polygon} The item instance the image was placed in.
   *&#x2F;
  pub.image = function(img, itemOrX, y, w, h) {
    var file = File(app.scriptPreferences.scriptsFolder.absoluteURI + &#x27;&#x2F;data&#x2F;&#x27; + img);
    if (!file.exists) {
      error(&#x27;The file &quot;&#x27; + file + &#x27;&quot; does not exist.&#x27;);
    }

    var frame = null,
      fitOptions = null;
    if (itemOrX instanceof Rectangle ||
        itemOrX instanceof Oval ||
        itemOrX instanceof Polygon) {
      frame = itemOrX;
    } else {
      var width = 1,
        height = 1;
      if (w &amp;&amp; h) {
        width = itemOrX + w;
        height = y + h;
        fitOptions = FitOptions.contentToFrame;
      } else {
        fitOptions = FitOptions.frameToContent;
      }
      
      frame = currentPage().rectangles.add();
      frame.geometricBounds = [y, itemOrX, y + height, itemOrX + width];
    }
    
    frame.place(file);

    &#x2F;&#x2F; embed graphic in document
    frame.graphics[0].itemLink.unlink();

    if (fitOptions) {
      frame.fit(fitOptions);
    }
    return frame;
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Math
  
  pub.PVector = function() {
    function PVector(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0
    }
    PVector.dist = function(v1, v2) {
      return v1.dist(v2)
    };
    PVector.dot = function(v1, v2) {
      return v1.dot(v2)
    };
    PVector.cross = function(v1, v2) {
      return v1.cross(v2)
    };
    PVector.angleBetween = function(v1, v2) {
      return Math.acos(v1.dot(v2) &#x2F; (v1.mag() * v2.mag()))
    };
    PVector.prototype = {
      set: function(v, y, z) {
        if (arguments.length === 1) this.set(v.x || v[0] || 0, v.y || v[1] || 0, v.z || v[2] || 0);
        else {
          this.x = v;
          this.y = y;
          this.z = z
        }
      },
      get: function() {
        return new PVector(this.x, this.y, this.z)
      },
      mag: function() {
        var x = this.x,
          y = this.y,
          z = this.z;
        return Math.sqrt(x * x + y * y + z * z)
      },
      add: function(v, y, z) {
        if (arguments.length === 1) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z
        } else {
          this.x += v;
          this.y += y;
          this.z += z
        }
      },
      sub: function(v, y, z) {
        if (arguments.length === 1) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z
        } else {
          this.x -= v;
          this.y -= y;
          this.z -= z
        }
      },
      mult: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x *= v;
          this.y *= v;
          this.z *= v
        } else {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z
        }
      },
      div: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x &#x2F;= v;
          this.y &#x2F;= v;
          this.z &#x2F;= v
        } else {
          this.x &#x2F;= v.x;
          this.y &#x2F;= v.y;
          this.z &#x2F;= v.z
        }
      },
      dist: function(v) {
        var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz)
      },
      dot: function(v, y, z) {
        if (arguments.length === 1) return this.x * v.x + this.y * v.y + this.z * v.z;
        return this.x * v + this.y * y + this.z * z
      },
      cross: function(v) {
        var x = this.x,
          y = this.y,
          z = this.z;
        return new PVector(y * v.z - v.y * z, z * v.x - v.z * x, x * v.y - v.x * y)
      },
      normalize: function() {
        var m = this.mag();
        if (m &gt; 0) this.div(m)
      },
      limit: function(high) {
        if (this.mag() &gt; high) {
          this.normalize();
          this.mult(high)
        }
      },
      heading2D: function() {
        return -Math.atan2(-this.y, this.x)
      },
      toString: function() {
        return &quot;[&quot; + this.x + &quot;, &quot; + this.y + &quot;, &quot; + this.z + &quot;]&quot;
      },
      array: function() {
        return [this.x, this.y, this.z]
      }
    };

    function createPVectorMethod(method) {
      return function(v1, v2) {
        var v = v1.get();
        v[method](v2);
        return v
      }
    }
    for (var method in PVector.prototype) if (PVector.prototype.hasOwnProperty(method) &amp;&amp; !PVector.hasOwnProperty(method)) PVector[method] = createPVectorMethod(method);
    return PVector
  }();
  
  pub.abs = Math.abs;

  pub.ceil = Math.ceil;

  pub.constrain = function(aNumber, aMin, aMax) {
    return aNumber &gt; aMax ? aMax : aNumber &lt; aMin ? aMin : aNumber
  };

  pub.dist = function() {
    var dx, dy, dz;
    if (arguments.length === 4) {
      dx = arguments[0] - arguments[2];
      dy = arguments[1] - arguments[3];
      return Math.sqrt(dx * dx + dy * dy)
    }
  };

  pub.exp = Math.exp;

  pub.floor = Math.floor;

  pub.lerp = function(value1, value2, amt) {
    return (value2 - value1) * amt + value1
  };

  pub.log = Math.log;

  pub.mag = function(a, b, c) {
    if (c) return Math.sqrt(a * a + b * b + c * c);
    return Math.sqrt(a * a + b * b)
  };

  pub.map = function(value, istart, istop, ostart, ostop) {
    return ostart + (ostop - ostart) * ((value - istart) &#x2F; (istop - istart))
  };

  pub.max = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[1] : arguments[0];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var max = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (max &lt; numbers[i]) max = numbers[i];
    return max
  };

  pub.min = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[0] : arguments[1];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var min = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (min &gt; numbers[i]) min = numbers[i];
    return min
  };

  pub.norm = function(aNumber, low, high) {
    return (aNumber - low) &#x2F; (high - low)
  };

  pub.pow = Math.pow;

  pub.round = Math.round;

  pub.sq = function(aNumber) {
    return aNumber * aNumber
  };
   
  pub.sqrt = Math.sqrt;
  pub.acos = Math.acos;
  pub.asin = Math.asin;
  pub.atan = Math.atan;
  pub.atan2 = Math.atan2;
  pub.cos = Math.cos;

  pub.degrees = function(aAngle) {
    return aAngle * 180 &#x2F; Math.PI
  };

  pub.radians = function(aAngle) {
    return aAngle &#x2F; 180 * Math.PI
  };

  pub.sin = Math.sin;
  pub.tan = Math.tan;

  var currentRandom = Math.random;
  pub.random = function() {
    if (arguments.length === 0) return currentRandom();
    if (arguments.length === 1) return currentRandom() * arguments[0];
    var aMin = arguments[0],
      aMax = arguments[1];
    return currentRandom() * (aMax - aMin) + aMin
  };

  function Marsaglia(i1, i2) {
    var z = i1 || 362436069,
      w = i2 || 521288629;
    var nextInt = function() {
      z = 36969 * (z &amp; 65535) + (z &gt;&gt;&gt; 16) &amp; 4294967295;
      w = 18E3 * (w &amp; 65535) + (w &gt;&gt;&gt; 16) &amp; 4294967295;
      return ((z &amp; 65535) &lt;&lt; 16 | w &amp; 65535) &amp; 4294967295
    };
    this.nextDouble = function() {
      var i = nextInt() &#x2F; 4294967296;
      return i &lt; 0 ? 1 + i : i
    };
    this.nextInt = nextInt
  }
  Marsaglia.createRandomized = function() {
    var now = new Date;
    return new Marsaglia(now &#x2F; 6E4 &amp; 4294967295, now &amp; 4294967295)
  };

  pub.randomSeed = function(seed) {
    currentRandom = (new Marsaglia(seed)).nextDouble
  };

  pub.Random = function(seed) {
    var haveNextNextGaussian = false,
      nextNextGaussian, random;
    this.nextGaussian = function() {
      if (haveNextNextGaussian) {
        haveNextNextGaussian = false;
        return nextNextGaussian
      }
      var v1, v2, s;
      do {
        v1 = 2 * random() - 1;
        v2 = 2 * random() - 1;
        s = v1 * v1 + v2 * v2
      } while (s &gt;= 1 || s === 0);
      var multiplier = Math.sqrt(-2 * Math.log(s) &#x2F; s);
      nextNextGaussian = v2 * multiplier;
      haveNextNextGaussian = true;
      return v1 * multiplier
    };
    random = seed === undef ? Math.random : (new Marsaglia(seed)).nextDouble
  };


  function PerlinNoise(seed) {
    var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();
    var i, j;
    var perm = new Uint8Array(512);
    for (i = 0; i &lt; 256; ++i) perm[i] = i;
    for (i = 0; i &lt; 256; ++i) {
      var t = perm[j = rnd.nextInt() &amp; 255];
      perm[j] = perm[i];
      perm[i] = t
    }
    for (i = 0; i &lt; 256; ++i) perm[i + 256] = perm[i];

    function grad3d(i, x, y, z) {
      var h = i &amp; 15;
      var u = h &lt; 8 ? x : y,
      v = h &lt; 4 ? y : h === 12 || h === 14 ? x : z;
      return ((h &amp; 1) === 0 ? u : -u) + ((h &amp; 2) === 0 ? v : -v)
    }
    function grad2d(i, x, y) {
      var v = (i &amp; 1) === 0 ? x : y;
      return (i &amp; 2) === 0 ? -v : v
    }
    function grad1d(i, x) {
      return (i &amp; 1) === 0 ? -x : x
    }
    function lerp(t, a, b) {
      return a + t * (b - a)
    }
    this.noise3d = function(x, y, z) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255,
        Z = Math.floor(z) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y,
        fz = (3 - 2 * z) * z * z;
      var p0 = perm[X] + Y,
        p00 = perm[p0] + Z,
        p01 = perm[p0 + 1] + Z,
        p1 = perm[X + 1] + Y,
        p10 = perm[p1] + Z,
        p11 = perm[p1 + 1] + Z;
      return lerp(fz, lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)), lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))), lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)), lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))))
    };
    this.noise2d = function(x, y) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y;
      var p0 = perm[X] + Y,
        p1 = perm[X + 1] + Y;
      return lerp(fy, lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)), lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1)))
    };
    this.noise1d = function(x) {
      var X = Math.floor(x) &amp; 255;
      x -= Math.floor(x);
      var fx = (3 - 2 * x) * x * x;
      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X + 1], x - 1))
    }
  }
  var noiseProfile = {
    generator: undef,
    octaves: 4,
    fallout: 0.5,
    seed: undef
  };
  pub.noise = function(x, y, z) {
    if (noiseProfile.generator === undef) noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
    var generator = noiseProfile.generator;
    var effect = 1,
      k = 1,
      sum = 0;
    for (var i = 0; i &lt; noiseProfile.octaves; ++i) {
      effect *= noiseProfile.fallout;
      switch (arguments.length) {
      case 1:
        sum += effect * (1 + generator.noise1d(k * x)) &#x2F; 2;
        break;
      case 2:
        sum += effect * (1 + generator.noise2d(k * x, k * y)) &#x2F; 2;
        break;
      case 3:
        sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) &#x2F; 2;
        break
      }
      k *= 2
    }
    return sum
  };
  pub.noiseDetail = function(octaves, fallout) {
    noiseProfile.octaves = octaves;
    if (fallout !== undef) noiseProfile.fallout = fallout
  };
  pub.noiseSeed = function(seed) {
    noiseProfile.seed = seed;
    noiseProfile.generator = undef
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Input
  
  &#x2F;**
   * Returns items tagged with the given label in the InDesign Script Label pane (Window -&gt; Utilities -&gt; Script Label).
   * 
   * @method findByLabel
   * @param  {String} label The label identifier
   * @return {PageItem[]} Array of concrete PageItem instances, e.g. TextFrame or SplineItem. 
   *&#x2F;
  pub.findByLabel = function(label) {
    var result = [];
    var doc = currentDoc();
    for (var i = 0, len = doc.pageItems.length; i &lt; len; i++) {
      var pageItem = doc.pageItems[i];
      if (pageItem.label === label) {
        &#x2F;&#x2F; push pageItem&#x27;s 1st element to get the concrete PageItem instance, e.g. a TextFrame 
        result.push(pageItem.getElements()[0]);
      }
    }
    return result;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Output
  
  pub.println = function(msg) {
    $.writeln(msg);
  };

  pub.print = function(msg) {
    $.write(msg);
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; all private from here

  var init = function() {
    glob.b = pub;

    &#x2F;&#x2F; -- init internal state vars --
    currStrokeWeight = 1;
    currStrokeTint = 100;
    currFillTint = 100;

    welcome();
    runUserScript();
  };

  var runUserScript = function() {
    app.doScript(function() {
      if (typeof glob.setup === &#x27;function&#x27;) {
        glob.setup();
      }
      if (typeof glob.draw === &#x27;function&#x27;) {
        glob.draw();
      }      
    }, ScriptLanguage.javascript, undefined, UndoModes.entireScript);
  };

  var welcome = function() {
    $.writeln(&quot;basil.js &quot;
        + pub.VERSION
        + &quot; &quot;
        + &quot;infos, feedback @ http:&#x2F;&#x2F;basiljs.ch&quot;);
  };
  
  var currentDoc = function() {
    if (!currDoc) {
      var doc = null;
      try {
        doc = app.activeDocument;  
      } catch(e) {
        doc = app.documents.add();
      }
      setCurrDoc(doc);
    }
    return currDoc;
  };

  var setCurrDoc = function(doc) {
    resetCurrDoc();
    currDoc = doc;
    &#x2F;&#x2F; -- setup document --
    currDoc.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;
    pub.units(pub.PT);
    updatePublicPageSizeVars();
  };

  var resetCurrDoc = function() {
    &#x2F;&#x2F; resets doc and doc specific vars
    currDoc = null;
    currPage = null;
    currLayer = null;
    currFillColor = &quot;Black&quot;;
    currNoFillColor = &quot;None&quot;;
    currStrokeColor = &quot;Black&quot;;
  };

  var currentLayer = function() {
    if (!currLayer) {
      currentDoc();
      currLayer = app.activeDocument.activeLayer;
    }
    return currLayer;
  };
  
  var currentPage = function() {
    if (!currPage) {
      currentDoc();
      currPage = app.activeWindow.activePage;
    }
    return currPage;
  };

  var updatePublicPageSizeVars = function () {
    var pageBounds = currentPage().bounds; &#x2F;&#x2F; [y1, x1, y2, x2]
    var w = pageBounds[3] - pageBounds[1];
    var h = pageBounds[2] - pageBounds[0];
    pub.width = w;
    pub.height = h;
  };

  var error = function(msg) {
    $.writeln(ERROR_PREFIX + msg);
    throw msg;
  };

  var warning = function(msg) {
    $.writeln(WARNING_PREFIX + msg);
  };
  
  init();
  
})(this, app);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
