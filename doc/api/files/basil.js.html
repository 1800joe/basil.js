<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>basil.js - basil.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;basiljs.ch&#x2F;basil2.jpg" title="basil.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/b.html">b</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: basil.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
  ..-  --.- ..- -.... -..-- .-..-. -.-..---.-.-....--.-- -....-.... -..-- .-.-..-.-.... .- .--

  B A S I L . J S
  An attempt to port the spirit of the Processing visualization language to Adobe Indesign.
  
  License        - MIT
  Developers     - Benedikt Gro√ü http:&#x2F;&#x2F;benedikt-gross.de
                 - Ludwig Zeller http:&#x2F;&#x2F;ludwigzeller.de
                 - Ted Davis http:&#x2F;&#x2F;teddavis.org
                 - Philipp Adrian http:&#x2F;&#x2F;www.philippadrian.com&#x2F;
  Contributers   - Stefan Landsbek, inital code architecture, http:&#x2F;&#x2F;47nord.de
  Web Site       - http:&#x2F;&#x2F;basiljs.ch
  Github Repo.   - https:&#x2F;&#x2F;github.com&#x2F;basiljs&#x2F;basil.js
  Processing     - http:&#x2F;&#x2F;processing.org
  Processing.js  - http:&#x2F;&#x2F;processingjs.org

  basil.js was conceived and is generously supported by
  The Visual Communication Institute &#x2F; The Basel School of Design
  Department of the Academy of Art and Design Basel (HGK FHNW)
  
  http:&#x2F;&#x2F;thebaselschoolofdesign.ch

  Please note: Big general parts e.g. random() of the basil.js source code are copy &amp; paste
  of the fantasic processing.js project created by John Resig. We would have had a hard time
  to figure all of that out on our own!

  Supported Adobe Indesign versions: CS 5, CS 5.5 and CS 6
  
  .--.--.- .-.-......-....--.-- -.... -..---.-.... .-- . .---.- -... -.-..---.-. ..--.-- -.. -
*&#x2F;

#target &quot;InDesign&quot;;

(function(glob, app, undef) {
  &#x2F;**
   * @class b
   * @static
   *&#x2F;
  var pub = {};


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; constants

  pub.VERSION = &quot;0.1&quot;;
  pub.PT = &quot;pt&quot;;
  pub.PX = &quot;px&quot;;
  pub.CM = &quot;cm&quot;;
  pub.MM = &quot;mm&quot;;
  pub.IN = &quot;inch&quot;;
  pub.CORNER = &quot;corner&quot;;
  pub.CORNERS = &quot;corners&quot;;
  pub.CENTER = &quot;center&quot;;
  pub.RADIUS = &quot;radius&quot;;
  pub.TWO_PI = Math.PI*2;
  pub.PI = Math.PI;
  pub.HALF_PI = Math.PI&#x2F;2;
  pub.QUARTER_PI = Math.PI&#x2F;4;
  
  var ERROR_PREFIX = &quot;\n\n### Basil Error -&gt; &quot;,
    WARNING_PREFIX = &quot;### Basil Warning -&gt; &quot;;


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; public vars
  
  &#x2F;**
   * System variable which stores the width of the current page.
   * @property width {Number}
   *&#x2F;
  pub.width = null;

  &#x2F;**
   * System variable which stores the height of the current page.
   * @property height {Number}
   *&#x2F;
  pub.height = null;

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; private vars
  var currDoc = null,
    currPage = null,
    currLayer = null,
    currUnits = null,
    currMatrix = null,
    matrixStack = null,
    currColorMode = null,
    currFillColor = null,
    currStrokeColor = null,
    currStrokeTint = null,
    currFillTint = null,
    currStrokeWeight = null,
    currRectMode = null,
    currEllipseMode = null,
    noneSwatchColor = null,
    start = null,
    currFont = null,
    currFontSize = null,
    currAlign = null,
    currYAlign = null,
    currLeading = null,
    currKerning = null,
    currTracking = null,
    currImageMode = null;

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; global functions


  &#x2F;* todo *&#x2F;
  &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;filter
  if (!Array.prototype.filter) {
    Array.prototype.filter = function(fun) {
      if (this === null) throw new TypeError();
      var t = Object(this);
      var len = t.length &gt;&gt;&gt; 0;
      if (typeof fun != &quot;function&quot;) throw new TypeError();
      var res = [];
      var thisp = arguments[1];
      for (var i = 0; i &lt; len; i++) {
        if (i in t) {
          var val = t[i]; &#x2F;&#x2F; in case fun mutates this
          if (fun.call(thisp, val, i, t)) res.push(val);
        }
      }
      return res;
    };
  }

  &#x2F;**
  * Used to run a function on all elements of an array. Please note the existance of the convenience methods b.stories(), b.paragraphs(), b.lines(), b.words() and b.characters() that are used to iterate through all instances of the given type in the given document.
  *
  * @method forEach
  * @param {Array} collection The array to be processed.
  * @param {Function} cb The function that will be called on each element. The call will be like function(item,i) where i is the current index of the item within the array.
  *&#x2F;
  if (!glob.forEach) {
    glob.forEach = function(collection, cb) {
      for (var i = 0, len = collection.length; i &lt; len; i++) {
        if(cb(collection[i],i) === false) {
          return false;
        }
      }
      return true;
    };
  }
  
  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Structure
  
  &#x2F;**
   * Suspends the calling thread for a number of milliseconds.
   * During a sleep period, checks at 100 millisecond intervals to see whether the sleep should be terminated.
   *
   * @method delay
   * @param  {Number} milliseconds  The delay time in milliseconds
   *&#x2F;
  pub.delay = function (milliseconds) {
    $.sleep(milliseconds);
  };

  &#x2F;**
   * Calls the given callback function with each story of the given document.
   *
   * @method stories
   * @param  {Document} doc The document instance to iterate the stories in
   * @param  {Function} cb  The callback function to call with each story. When this function returns false the loop stops. Passed arguments: story, loopCount;
   *&#x2F;
  pub.stories = function(doc, cb) {
    return forEach(doc.stories, cb);
  };

  &#x2F;**
   * Calls the given callback function with each paragraph of the given document, story or text frame.
   *
   * @method paragraphs
   * @param  {Document|Story|TextFrame} item The story or text frame instance to iterate the paragraphs in
   * @param  {Function} cb  The callback function to call with each paragraph. When this function returns false the loop stops. Passed arguments: para, loopCount
   *&#x2F;
  pub.paragraphs = function(item, cb) {
    if (item instanceof Document) {
      return forEachStoryProperty(item, &#x27;paragraphs&#x27;, cb);
    } else {
      return forEach(item.paragraphs, cb);
    }
  };

  &#x2F;**
   * Calls the given callback function with each line of the given document, story, text frame or paragraph.
   *
   * @method lines
   * @param  {Document|Story|TextFrame|Paragraph} item The document, story, text frame or paragraph instance to
   *                                                   iterate the lines in
   * @param  {Function} cb The callback function to call with each line. When this function returns false the loop stops. Passed arguments: line, loopCount
   *&#x2F;
  pub.lines = function(item, cb) {
    if (item instanceof Document) {
      return forEachStoryProperty(item, &#x27;lines&#x27;, cb);
    } else {
      return forEach(item.lines, cb);
    }
  };

  &#x2F;**
   * Calls the given callback function with each word of the given document, story, text frame, paragraph or line.
   *
   * @method words
   * @param  {Document|Story|TextFrame|Paragraph|Line} item The document, story, text frame, paragraph or line instance
   *                                                        to iterate the words in
   * @param  {Function} cb The callback function to call with each word. When this function returns false the loop stops. Passed arguments: word, loopCount
   *&#x2F;
  pub.words = function(item, cb) {
    if (item instanceof Document) {
      return forEachStoryProperty(item, &#x27;words&#x27;, cb);
    } else {
      return forEach(item.words, cb);
    }
  };

  &#x2F;**
   * Calls the given callback function with each character of the given document, story, text frame, paragraph, line or word.
   *
   * @method characters
   * @param  {Document|Story|TextFrame|Paragraph|Line|Word} item The document, story, text frame, paragraph, line or word instance to
   *                                                    iterate the characters in
   * @param  {Function} cb The callback function to call with each character. When this function returns false the loop stops. Passed arguments: character, loopCount
   *&#x2F;
  pub.characters = function(item, cb) {
    if (item instanceof Document) {
      return forEachStoryProperty(item, &#x27;characters&#x27;, cb);
    } else {
      return forEach(item.characters, cb);
    }
  };

  var forEachStoryProperty = function(doc, property, cb) {
    var loopCount = 0;
    pub.stories(doc, function(story) {
      var properties = story[property];
      for (var i = 0, len = properties.length; i &lt; len; i++) {
        if(cb(properties[i], loopCount++) === false) {
          return false;
        }
      }
      return true;
    });
  };

  &#x2F;**
   * Checks whether a var is an Array, returns true if this is the case
   *
   * @method isArray
   * @param  {Object|String|Number}  obj The object to check
   * @return {Boolean}     [description]
   *&#x2F;
  var isArray = pub.isArray = function(obj) {
    return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;
  };

  &#x2F;**
   * Checks whether a var is a number, returns true if this is the case
   *
   * @method isNumber
   * @param  {Object|String|Number}  num The number to ckeck
   * @return {Boolean}
   *&#x2F;
  var isNumber = pub.isNumber = function(num) {
    return !isNaN(parseFloat(num)) &amp;&amp; isFinite(num);
  };

  &#x2F;**
   * Checks whether a var is a indesign text object, returns true if this is the case
   *
   * @method isText
   * @param  {Character|InsertionPoint|Line|Paragraph|TextColumn|TextStyleRange|Word}  obj The object to check
   * @return {Boolean}     [description]
   *&#x2F;
  var isText = pub.isText = function(obj) {
    return obj instanceof Character ||
           obj instanceof InsertionPoint ||
           obj instanceof Line ||
           obj instanceof Paragraph ||
           obj instanceof TextColumn ||
           obj instanceof TextStyleRange ||
           obj instanceof Word;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Environment
  
  &#x2F;**
   * Sets or possibly creates the current document and returns it.
   * If the param doc is not given the current document gets set to the active document
   * in the application. If no document at all is open, a new document gets created.
   *
   * @method doc
   * @param  {Document} [doc] The document to set the current document to
   * @return {Document} The current document instance
   *&#x2F;
  pub.doc = function(doc) {
    if (doc instanceof Document) {
      setCurrDoc(doc);
    }
    return currentDoc();
  };

  &#x2F;**
   * Closes the current document.
   *
   * @method close
   * @param  {SaveOptions} [saveOptions] The indesign SaveOptions constant
   * @param  {File} [file] The indesign file instance to save the document to
   *&#x2F;
  pub.close = function(saveOptions, file) {
    var doc = currentDoc();
    if (doc) {
      doc.close(saveOptions, file);
      resetCurrDoc();
    }
  };

  &#x2F;**
   * Returns the current page and sets it if argument page is given.
   *
   * @method page
   * @param  {Page|Number} [page] The page or page index to set the current page to
   * @return {Page} The current page instance
   *&#x2F;
  pub.page = function(page) {
    if (page instanceof Page) {
      currPage = page;
    } else if (typeof page === &#x27;number&#x27;) {
      var tempPage = currentDoc().pages[page];
      try {
        tempPage.id;
      } catch (e) {
        error(&#x27;Page &#x27; + page + &#x27; does not exist.&#x27;);
      }
      currPage = tempPage;
    }
    updatePublicPageSizeVars();
    return currentPage();
  };

  &#x2F;**
   * Returns the current layer and sets it if argument layer is given.
   *
   * @method layer
   * @param  {Layer|String} [layer] The layer or layer name to set the current layer to
   * @return {Layer} The current layer instance
   *&#x2F;
  pub.layer = function(layer) {
    if (layer instanceof Layer) {
      currLayer = layer;
    } else if (typeof layer === &#x27;string&#x27;) {
      var layers = currentDoc().layers;
      currLayer = layers.item(layer);
      if (!currLayer.isValid) {
        currLayer = layers.add({name: layer});
      }
    }
    return currentLayer();
  };

  &#x2F;**
   * Sets the units of the document (like right clicking the rulers).
   *
   * @method units
   * @param  {Constant} [units] Supported units: PT, PX, CM, MM or IN
   * @return {Constant} Current unit setting
   *&#x2F;
  pub.units = function (units) {
    if (arguments.length === 0) return currUnits;

    if (units === pub.CM ||
        units === pub.MM ||
        units === pub.PT ||
        units === pub.PX ||
        units === pub.IN) {
      var unitType = null;
      if      (units === pub.CM) unitType = MeasurementUnits.centimeters;
      else if (units === pub.MM) unitType = MeasurementUnits.millimeters;
      else if (units === pub.PT) unitType = MeasurementUnits.points;
      else if (units === pub.PX) unitType = MeasurementUnits.pixels;
      else if (units === pub.IN) unitType = MeasurementUnits.inches;
      var doc = currentDoc();
      with (doc.viewPreferences){
        &#x2F;&#x2F;* MeasurementUnits.agates
        &#x2F;&#x2F;* MeasurementUnits.picas
        &#x2F;&#x2F;* MeasurementUnits.points
        &#x2F;&#x2F;* MeasurementUnits.inches
        &#x2F;&#x2F;* MeasurementUnits.inchesDecimal
        &#x2F;&#x2F;* MeasurementUnits.millimeters
        &#x2F;&#x2F;* MeasurementUnits.centimeters
        &#x2F;&#x2F;* MeasurementUnits.ciceros
        horizontalMeasurementUnits = unitType;
        verticalMeasurementUnits = unitType;
      }
      currUnits = units;
      updatePublicPageSizeVars();
    } else {
      error(&quot;Not supported unit&quot;);
    }
    return currUnits;
  };

  &#x2F;**
   * Creates a vertical guide line at the current spread and current layer.
   *
   * @method guideX
   * @param  {Number} x Position of the new guide
   * @return {Guide} New guide
   *&#x2F;
  pub.guideX = function (x) {
    var guides = currentPage().guides;
    var guide = guides.add( currentLayer() );
    with (guide) {
      fitToPage = true;
      orientation = HorizontalOrVertical.VERTICAL;
      location = x;
    }
    return guide;
  };

  &#x2F;**
   * Creates a horizontal guide line at the current spread and current layer.
   *
   * @method guideY
   * @param  {Number} y Position of the new guide
   * @return {Guide} New guide
   *&#x2F;
  pub.guideY = function (y) {
    var guides = currentPage().guides;
    var guide = guides.add( currentLayer() );
    with (guide) {
      fitToPage = true;
      orientation = HorizontalOrVertical.HORIZONTAL;
      location = y;
    }
    return guide;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Data
  

  pub.JSON = {
    &#x2F;*
     * Function parses and validates a string as JSON-object. Usage:
     * var obj = b.JSON.decode(str);
     * var str = b.JSON.encode(obj);
     *
     * @method JSON.decode()
     * @param  {String} String to be parsed as JSON-object.
     * @return {Object} Returns JSON-object or throws an error if invalid JSON has been provided.
    *&#x2F;
    &#x2F;&#x2F; From: jQuery JavaScript Library v1.7.1 http:&#x2F;&#x2F;jquery.com&#x2F;
    decode: function( data ) {
      if ( typeof data !== &quot;string&quot; || !data ) {
        return null;
      }
      var rvalidchars = &#x2F;^[\],:{}\s]*$&#x2F;,
        rvalidescape = &#x2F;\\(?:[&quot;\\\&#x2F;bfnrt]|u[0-9a-fA-F]{4})&#x2F;g,
        rvalidtokens = &#x2F;&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?&#x2F;g,
        rvalidbraces = &#x2F;(?:^|:|,)(?:\s*\[)+&#x2F;g;

      &#x2F;&#x2F; Make sure the incoming data is actual JSON
      &#x2F;&#x2F; Logic borrowed from http:&#x2F;&#x2F;json.org&#x2F;json2.js
      if ( rvalidchars.test( data.replace( rvalidescape, &quot;@&quot; )
        .replace( rvalidtokens, &quot;]&quot; )
        .replace( rvalidbraces, &quot;&quot;)) ) {
        return ( new Function( &quot;return &quot; + data ) )();
      }
      error( &quot;Invalid JSON: &quot; + data );
    },
    &#x2F;**
     * Function convert an javascript object to a JSON-string. Usage:
     * var str = b.JSON.encode(obj);
     * var obj = b.JSON.decode(str);
     * 
     * @method JSON.encode()
     * @param  {Object} Object to be converted to a JSON-string
     * @return {String} Returns JSON-string
     *&#x2F;
    &#x2F;&#x2F; From: https:&#x2F;&#x2F;gist.github.com&#x2F;754454
    encode: function(obj) {
      var t = typeof (obj);
      if (t !== &quot;object&quot; || obj === null) {
        &#x2F;&#x2F; simple data type
        if (t === &quot;string&quot;) obj = &#x27;&quot;&#x27; + obj + &#x27;&quot;&#x27;;
        return String(obj);
      } else {
        &#x2F;&#x2F; recurse array or object
        var n, v, json = [], arr = (obj &amp;&amp; obj.constructor === Array);

        for (n in obj) {
          v = obj[n];
          t = typeof(v);
          if (obj.hasOwnProperty(n)) {
            if (t === &quot;string&quot;) v = &#x27;&quot;&#x27; + v + &#x27;&quot;&#x27;; else if (t === &quot;object&quot; &amp;&amp; v !== null) v = pub.JSON.encode(v);
            json.push((arr ? &quot;&quot; : &#x27;&quot;&#x27; + n + &#x27;&quot;:&#x27;) + String(v));
          }
        }
        return (arr ? &quot;[&quot; : &quot;{&quot;) + String(json) + (arr ? &quot;]&quot; : &quot;}&quot;);
      }
    }
  };

  &#x2F;&#x2F; -- Conversion --
  
  &#x2F;** 
   * Converts a byte, char, int, or color to a String containing the
   * equivalent binary notation. For example color(0, 102, 153, 255) 
   * will convert to the String &quot;11111111000000000110011010011001&quot;. This 
   * function can help make your geeky debugging sessions much happier.
   *
   * @method binary
   * @param {Number} num value to convert
   * @param {Number} [numBits] number of digits to return
   * @return {String} A formatted string
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;binary_&#x2F;
  pub.binary = function(num, numBits) {
    var bit;
    if (numBits &gt; 0) bit = numBits;
    else if (num instanceof Char) {
      bit = 16;
      num |= 0;
    } else {
      bit = 32;
      while (bit &gt; 1 &amp;&amp; !(num &gt;&gt;&gt; bit - 1 &amp; 1)) bit--;
    }
    var result = &quot;&quot;;
    while (bit &gt; 0) result += num &gt;&gt;&gt; --bit &amp; 1 ? &quot;1&quot; : &quot;0&quot;;
    return result;
  };

  &#x2F;** 
   * Converts a String representation of a binary number to its 
   * equivalent integer value. For example, unbinary(&quot;00001000&quot;) will 
   * return 8.
   *
   * @method unbinary
   * @param {String} binaryString value to convert
   * @return {Number} The integer representation
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;unbinary_&#x2F;
  pub.unbinary = function(binaryString) {
    var i = binaryString.length - 1,
      mask = 1,
      result = 0;
    while (i &gt;= 0) {
      var ch = binaryString[i--];
      if (ch !== &quot;0&quot; &amp;&amp; ch !== &quot;1&quot;) throw &quot;the value passed into unbinary was not an 8 bit binary number&quot;;
      if (ch === &quot;1&quot;) result += mask;
      mask &lt;&lt;= 1;
    }
    return result;
  };


  var decimalToHex = function(d, padding) {
    padding = padding === undef || padding === null ? padding = 8 : padding;
    if (d &lt; 0) d = 4294967295 + d + 1;
    var hex = Number(d).toString(16).toUpperCase();
    while (hex.length &lt; padding) hex = &quot;0&quot; + hex;
    if (hex.length &gt;= padding) hex = hex.substring(hex.length - padding, hex.length);
    return hex;
  };

  &#x2F;**
   * Convert a number to a hex representation. 
   *
   * @method hex
   * @param {Number} value The number to convert
   * @param {Number} [len] The length of the hex number to be created, default: 8
   * @return {String} The hex representation as a string
   *&#x2F;
  pub.hex = function(value, len) {
    if (arguments.length === 1) len = 8;
    return decimalToHex(value, len);
  };

  var unhexScalar = function(hex) {
    var value = parseInt(&quot;0x&quot; + hex, 16);
    if (value &gt; 2147483647) value -= 4294967296;
    return value;
  }

  &#x2F;**
   * Convert a hex representation to a number.
   *
   * @method unhex
   * @param {String} hex The hex representation
   * @return {Number} The number
   *&#x2F;
  pub.unhex = function(hex) {
    if (hex instanceof Array) {
      var arr = [];
      for (var i = 0; i &lt; hex.length; i++) arr.push(unhexScalar(hex[i]));
      return arr;
    }
    return unhexScalar(hex);
  };


  &#x2F;&#x2F; -- String Functions --

  &#x2F;**
   * Combines an array of Strings into one String, each separated by 
   * the character(s) used for the separator parameter. To join arrays 
   * of ints or floats, it&#x27;s necessary to first convert them to strings 
   * using nf() or nfs().
   *
   * @method join
   * @param {Array} array A string array
   * @param {String} separator The separator to be inserted
   * @return {String} The joined string
   *&#x2F;
   &#x2F;&#x2F; http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;join_&#x2F;
  pub.join = function(array, separator) {
    return array.join(separator);
  };

  &#x2F;**
   * The split() function breaks a string into pieces using a
   * character or string as the divider. The delim parameter specifies the
   * character or characters that mark the boundaries between each piece. A
   * String[] array is returned that contains each of the pieces.
   *
   * If the result is a set of numbers, you can convert the String[] array
   * to to a float[] or int[] array using the datatype conversion functions
   * int() and float() (see example above).
   *
   * The splitTokens() function works in a similar fashion, except that it
   * splits using a range of characters instead of a specific character or
   * sequence.    
   *  
   * @method split
   * @param {String} str the String to be split
   * @param {String} [delim] The string used to separate the data
   * @return {Array} Array of strings
   *&#x2F;
   &#x2F;&#x2F; http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;split_&#x2F;
  pub.split = function(str, delim) {     
    return str.split(delim);   
  };

  &#x2F;**
   * The splitTokens() function splits a String at one or many character 
   * &quot;tokens.&quot; The tokens parameter specifies the character or characters 
   * to be used as a boundary.
   *
   * If no tokens character is specified, any whitespace character is used 
   * to split. Whitespace characters include tab (\t), line feed (\n), 
   * carriage return (\r), form feed (\f), and space. To convert a String 
   * to an array of integers or floats, use the datatype conversion functions 
   * int() and float() to convert the array of Strings.
   *  
   * @method splitTokens
   * @param {String} str the String to be split
   * @param {String} [tokens] list of individual characters that will be used as separators
   * @return {Array} Array of strings
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;splitTokens_&#x2F;
  pub.splitTokens = function(str, tokens) {
    if (arguments.length === 1) tokens = &quot;\n\t\r\u000c &quot;;
    tokens = &quot;[&quot; + tokens + &quot;]&quot;;
    var ary = [];
    var index = 0;
    var pos = str.search(tokens);
    while (pos &gt;= 0) {
      if (pos === 0) str = str.substring(1);
      else {
        ary[index] = str.substring(0, pos);
        index++;
        str = str.substring(pos);
      }
      pos = str.search(tokens);
    }
    if (str.length &gt; 0) ary[index] = str;
    if (ary.length === 0) ary = undef;
    return ary;
  };  

  &#x2F;* todo *&#x2F;
  pub.match = function(str, regexp) {
    return str.match(regexp);
  };

  &#x2F;* todo *&#x2F;
  pub.matchAll = function(aString, aRegExp) {
    var results = [],
      latest;
    var regexp = new RegExp(aRegExp, &quot;g&quot;);
    while ((latest = regexp.exec(aString)) !== null) {
      results.push(latest);
      if (latest[0].length === 0)++regexp.lastIndex;
    }
    return results.length &gt; 0 ? results : null;
  };

  function nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group) {
    var sign = value &lt; 0 ? minus : plus;
    var autoDetectDecimals = rightDigits === 0;
    var rightDigitsOfDefault = rightDigits === undef || rightDigits &lt; 0 ? 0 : rightDigits;
    var absValue = Math.abs(value);
    if (autoDetectDecimals) {
      rightDigitsOfDefault = 1;
      absValue *= 10;
      while (Math.abs(Math.round(absValue) - absValue) &gt; 1.0E-6 &amp;&amp; rightDigitsOfDefault &lt; 7) {
        ++rightDigitsOfDefault;
        absValue *= 10;
      }
    } else if (rightDigitsOfDefault !== 0) absValue *= Math.pow(10, rightDigitsOfDefault);
    var number, doubled = absValue * 2;
    if (Math.floor(absValue) === absValue) number = absValue;
    else if (Math.floor(doubled) === doubled) {
      var floored = Math.floor(absValue);
      number = floored + floored % 2;
    } else number = Math.round(absValue);
    var buffer = &quot;&quot;;
    var totalDigits = leftDigits + rightDigitsOfDefault;
    while (totalDigits &gt; 0 || number &gt; 0) {
      totalDigits--;
      buffer = &quot;&quot; + number % 10 + buffer;
      number = Math.floor(number &#x2F; 10);
    }
    if (group !== undef) {
      var i = buffer.length - 3 - rightDigitsOfDefault;
      while (i &gt; 0) {
        buffer = buffer.substring(0, i) + group + buffer.substring(i);
        i -= 3;
      }
    }
    if (rightDigitsOfDefault &gt; 0) return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) + &quot;.&quot; + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);
    return sign + buffer;
  }
  function nfCore(value, plus, minus, leftDigits, rightDigits, group) {
    if (value instanceof Array) {
      var arr = [];
      for (var i = 0, len = value.length; i &lt; len; i++) arr.push(nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));
      return arr;
    }
    return nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);
  }

  &#x2F;**    
   * Utility function for formatting numbers into strings. There
   * are two versions, one for formatting floats and one for formatting
   * ints. The values for the digits, left, and right parameters should
   * always be positive integers.

   * As shown in the above example, nf() is used to add zeros to the
   * left and&#x2F;or right of a number. This is typically for aligning a list
   * of numbers. To remove digits from a floating-point number, use the
   * int(), ceil(), floor(), or round() functions.    
   * 
   * @method nf
   * @param {Number} value The Number to convert
   * @param {Number} leftDigits
   * @param {Number} rightDigits   
   * @return {String} The formatted string
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nf_&#x2F;
  pub.nf = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits);
  };

  &#x2F;**    
   * Utility function for formatting numbers into strings. Similar to nf() 
   * but leaves a blank space in front of positive numbers so they align 
   * with negative numbers in spite of the minus symbol. There are two 
   * versions, one for formatting floats and one for formatting ints. The 
   * values for the digits, left, and right parameters should always be 
   * positive integers.   
   * 
   * @method nfs
   * @param {Number} value The Number to convert
   * @param {Number} leftDigits
   * @param {Number} rightDigits   
   * @return {String} The formatted string
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfs_&#x2F;
  pub.nfs = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot; &quot;, &quot;-&quot;, leftDigits, rightDigits);
  };
  
  &#x2F;**    
   * Utility function for formatting numbers into strings. Similar to nf() 
   * but puts a &quot;+&quot; in front of positive numbers and a &quot;-&quot; in front of 
   * negative numbers. There are two versions, one for formatting floats 
   * and one for formatting ints. The values for the digits, left, and right 
   * parameters should always be positive integers.      
   * 
   * @method nfp
   * @param {Number} value The Number to convert
   * @param {Number} leftDigits
   * @param {Number} rightDigits   
   * @return {String} The formatted string
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfp_&#x2F;
  pub.nfp = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;+&quot;, &quot;-&quot;, leftDigits, rightDigits);
  };

  &#x2F;**    
   * Utility function for formatting numbers into strings and placing 
   * appropriate commas to mark units of 1000. There are two versions, one 
   * for formatting ints and one for formatting an array of ints. The value 
   * for the digits parameter should always be a positive integer.     
   * 
   * @method nfc
   * @param {Number} value The Number to convert
   * @param {Number} leftDigits
   * @param {Number} rightDigits   
   * @return {String} The formatted string
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfc_&#x2F;
  pub.nfc = function(value, leftDigits, rightDigits) {
    return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits, &quot;,&quot;);
  };


  &#x2F;**    
   * Removes whitespace characters from the beginning and end of a String. 
   * In addition to standard whitespace characters such as space, carriage 
   * return, and tab, this function also removes the Unicode &quot;nbsp&quot; character.    
   * 
   * @method trim
   * @param {String|Array} str A string or an array of strings to be trimmed
   * @return {String|Array} Returns the input in a trimmed way
   *&#x2F;
   &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;trim_&#x2F;
  pub.trim = function(str) {
    if (str instanceof Array) {
      var arr = [];
      for (var i = 0; i &lt; str.length; i++) arr.push(str[i].replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;));
      return arr;
    }
    return str.replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;);
  };

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Shape
  
  &#x2F;**
   * Draws an ellipse (oval) in the display window. An ellipse with an equal &lt;b&gt;width&lt;&#x2F;b&gt; and &lt;b&gt;height&lt;&#x2F;b&gt; is a circle.
   * The first two parameters set the location, the third sets the width, and the fourth sets the height.
   *
   * @method ellipse
   * @param  {Number} x Location X
   * @param  {Number} y Location Y
   * @param  {Number} w Width
   * @param  {Number} h Height
   * @return {Oval} New oval (n.b. in Adobe Scripting the corresponding type is Oval, not Ellipse)
   *&#x2F;
  pub.ellipse = function(x, y, w, h){
    if (arguments.length !== 4) error(&quot;Not enough parameters to draw a ellipse! Use: x, y, w, h&quot;);
    var ellipseBounds = [];
    if (currEllipseMode === pub.CORNER) {
      ellipseBounds[0] = y;
      ellipseBounds[1] = x;
      ellipseBounds[2] = (y+h);
      ellipseBounds[3] = (x+w);
    } else if (currEllipseMode === pub.CORNERS) {
      ellipseBounds[0] = y;
      ellipseBounds[1] = x;
      ellipseBounds[2] = h;
      ellipseBounds[3] = w;
    } else if (currEllipseMode === pub.CENTER) {
      ellipseBounds[0] = y-(h&#x2F;2);
      ellipseBounds[1] = x-(w&#x2F;2);
      ellipseBounds[2] = (y+h)-(h&#x2F;2);
      ellipseBounds[3] = (x+w)-(w&#x2F;2);
    } else if (currEllipseMode === pub.RADIUS) {
      ellipseBounds[0] = y-(h);
      ellipseBounds[1] = x-(w);
      ellipseBounds[2] = y+(h);
      ellipseBounds[3] = x+(w);
    }

    var ovals = currentPage().ovals;
    var newOval = ovals.add( currentLayer() );
    with (newOval) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      strokeColor = currStrokeColor;
      geometricBounds = ellipseBounds;
    }

    if (currEllipseMode === pub.CENTER || currEllipseMode === pub.RADIUS) {
      newOval.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      newOval.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    }
    return newOval;
  };

  &#x2F;**
   * Draws a line (a direct path between two points) to the page.
   *
   * @method line
   * @param  {Number} x1 Point A x-value
   * @param  {Number} y1 Point A y-value
   * @param  {Number} x2 Point B x-value
   * @param  {Number} y2 Point B y-value
   * @return {GraphicLine} New GraphicLine
   *&#x2F;
  pub.line = function(x1, y1, x2, y2) {
    if (arguments.length !== 4) error(&quot;Not enough parameters to draw a line! Use: x1, y1, x2, y2&quot;);
    var lines = currentPage().graphicLines;
    var newLine = lines.add( currentLayer() );
    with (newLine) {
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      strokeColor = currStrokeColor;
    }
    newLine.paths.item(0).entirePath = [[x1, y1], [x2, y2]];
    newLine.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    return newLine;
  };

  &#x2F;**
   * Draws a rectangle to the page.
   *
   * @method rect
   * @param  {Number} x Position X
   * @param  {Number} y Position Y
   * @param  {Number} w Width
   * @param  {Number} h Height
   * @return {Rectangle} New rectangle
   *&#x2F;
  pub.rect = function(x, y, w, h){
    if (arguments.length !== 4) error(&quot;Not enough parameters to draw a rect! Use: x, y, w, h&quot;);
    var rectBounds = [];
    if (currRectMode === pub.CORNER) {
      rectBounds[0] = y;
      rectBounds[1] = x;
      rectBounds[2] = (y+h);
      rectBounds[3] = (x+w);
    } else if (currRectMode === pub.CORNERS) {
      rectBounds[0] = y;
      rectBounds[1] = x;
      rectBounds[2] = h;
      rectBounds[3] = w;
    } else if (currRectMode === pub.CENTER) {
      rectBounds[0] = y-(h&#x2F;2);
      rectBounds[1] = x-(w&#x2F;2);
      rectBounds[2] = (y+h)-(h&#x2F;2);
      rectBounds[3] = (x+w)-(w&#x2F;2);
    }
    
    var newRect = currentPage().rectangles.add( currentLayer() );
    with (newRect) {
      geometricBounds = rectBounds;
      strokeWeight = currStrokeWeight;
      strokeTint = currStrokeTint;
      fillColor = currFillColor;
      fillTint = currFillTint;
      strokeColor = currStrokeColor;
    }

    if (currRectMode === pub.CENTER) {
      newRect.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      newRect.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    }
    return newRect;
  };

  &#x2F;**
   * The function calculates the geometric bounds of any given object.
   * In case the object is any kind of text, then additional typographic information baseline and xHeight are calculated
   *
   * @method bounds
   * @param  {Text|Object} obj The object to calculate the geometric bounds
   * @return {Object} Geometric bounds object with these properties: width, height, left, right, top, bottom and for text: baseline, xHeight
   *&#x2F;
  pub.bounds = function (obj) {
    var x1,y1,x2,y2,w,h;

    if (isText(obj)) {
      var baseline = obj.baseline;
      var ascent = obj.ascent;
      var descent = obj.descent;

      x1 = obj.horizontalOffset;
      y1 = baseline - ascent;
      x2 = obj.endHorizontalOffset;
      y2 = baseline + descent;
      w = x2-x1;
      h = y2-y1;

      if (w &lt; 0 || h &lt;0) {
        warning(&quot;bounds(textObj), not possible to get correct bounds, possible linebreak within textObj&quot;);
      }

      &#x2F;&#x2F; TODO: not sure if this 100% correct, check
      &#x2F;&#x2F; http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;File:Typography_Line_Terms.svg
      var xHeight = y1+descent;

      return {&#x27;width&#x27;:w,
              &#x27;height&#x27;:h,
              &#x27;left&#x27;:x1,
              &#x27;right&#x27;:x2,
              &#x27;top&#x27;:y1,
              &#x27;bottom&#x27;:y2,
              &#x27;baseline&#x27;:baseline,
              &#x27;xHeight&#x27;:xHeight };
    } else {
      &#x2F;&#x2F; is it a pageItem?
      if (obj.hasOwnProperty(&quot;geometricBounds&quot;)) {
        var geometricBounds = obj.geometricBounds; &#x2F;&#x2F;[y1, x1, y2, x2]
        x1 = geometricBounds[1];
        y1 = geometricBounds[0];
        x2 = geometricBounds[3];
        y2 = geometricBounds[2];
        w = x2-x1;
        h = y2-y1;
        return {&#x27;width&#x27;:w, &#x27;height&#x27;:h, &#x27;left&#x27;:x1, &#x27;right&#x27;:x2, &#x27;top&#x27;:y1, &#x27;bottom&#x27;:y2};
      }
      &#x2F;&#x2F; everything else e.g. page, spread
      else if (obj.hasOwnProperty(&quot;bounds&quot;)) {
        var bounds = obj.bounds; &#x2F;&#x2F;[y1, x1, y2, x2]
        x1 = bounds[1];
        y1 = bounds[0];
        x2 = bounds[3];
        y2 = bounds[2];
        w = x2-x1;
        h = y2-y1;
        return {&#x27;width&#x27;:w, &#x27;height&#x27;:h, &#x27;left&#x27;:x1, &#x27;right&#x27;:x2, &#x27;top&#x27;:y1, &#x27;bottom&#x27;:y2};
      }
      &#x2F;&#x2F; no idea what that might be, give up
      else {
        error(&quot;bounds(obj), invalide type! Can&#x27;t get bounds for this object.&quot;);
      }
    }
  };

  &#x2F;&#x2F; -- Attributes --

  &#x2F;* todo *&#x2F;
  pub.rectMode = function (mode) {
    if (arguments.length === 0) return currRectMode;
    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER ) {
      currRectMode = mode;
      return currRectMode;
    } else {
      error(&quot;Unsupported rectMode. Use: CORNER, CORNERS, CENTER.&quot;);
    }
  };

  &#x2F;* todo *&#x2F;
  pub.ellipseMode = function (mode) {
    if (arguments.length === 0) return currEllipseMode;
    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER || mode === pub.RADIUS ) {
      currEllipseMode = mode;
      return currEllipseMode;
    } else {
      error(&quot;Unsupported ellipseMode. Use: CENTER, RADIUS, CORNER, CORNERS.&quot;);
    }
  };

  &#x2F;* todo *&#x2F;
  pub.strokeWeight = function (weight) {
    if (typeof weight === &#x27;string&#x27; || typeof weight === &#x27;number&#x27;) {
      currStrokeWeight = weight;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Returns the object style with the given name. If the style does not exist it gets created.
   *
   * @method objectStyle
   * @param  {String} name  The name of the object style to return.
   * @return {ObjectStyle}  The object style instance.
   *&#x2F;
  pub.objectStyle = function(name) {
    var style = null;
    try {
      style = currentDoc().objectStyles.item(name);
      style.name;
    } catch (e) {
      style = currentDoc().objectStyles.add({name: name});
    }
    return style;
  };
  


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Color
  
  &#x2F;**
   * Sets the color used to fill shapes.
   * @method fill
   * @param  {Color|Swatch|Numbers} fillColor  Accepts a Color&#x2F;swatch or a string with the name of a color. Or values: C,M,Y,K &#x2F; R,G,B &#x2F; Grey
   *&#x2F;
  pub.fill = function (fillColor) {
    if (fillColor instanceof Color || fillColor instanceof Swatch) {
      currFillColor = fillColor;
    } else {
      if (arguments.length === 1) {
        currFillColor = pub.color(arguments[0]);
      } else if (arguments.length === 2) {
        currFillColor = pub.color(arguments[0],arguments[1]);
      } else if (arguments.length === 3) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2]);
      } else if (arguments.length === 4) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3]);
      } else if (arguments.length === 5) {
        currFillColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
      } else {
        error(&quot;Wrong parameters. Use: &quot;
          + &quot;R,G,B,name or &quot;
          + &quot;C,M,Y,K,name. &quot;
          + &quot;Grey,name &quot;
          + &quot;Name is optional&quot;);
      }
    }
  };

  &#x2F;* todo *&#x2F;
  pub.noFill = function () {
    currFillColor = noneSwatchColor;
  };

  &#x2F;**
   * Sets the color used to draw lines and borders around shapes.
   * @method stroke
   * @param  {Color|Swatch|Numbers} strokeColor  Accepts a Color&#x2F;swatch or a string with the name of a color. Or values: C,M,Y,K &#x2F; R,G,B &#x2F; Grey
   *&#x2F;
  pub.stroke = function (strokeColor) {
    if (strokeColor instanceof Color || strokeColor instanceof Swatch) {
      currStrokeColor = strokeColor;
    } else {
      if (arguments.length === 1) {
        currStrokeColor = pub.color(arguments[0]);
      } else if (arguments.length === 2) {
        currStrokeColor = pub.color(arguments[0],arguments[1]);
      } else if (arguments.length === 3) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2]);
      } else if (arguments.length === 4) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3]);
      } else if (arguments.length === 5) {
        currStrokeColor = pub.color(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
      } else {
        error(&quot;Wrong parameters. Use: &quot;
          + &quot;R,G,B,name or &quot;
          + &quot;C,M,Y,K,name. &quot;
          + &quot;Grey,name &quot;
          + &quot;Name is optional&quot;);
      }
    }
  };

  &#x2F;* todo *&#x2F;
  pub.noStroke = function () {
    currStrokeColor = noneSwatchColor;
  };

  &#x2F;**
   * Sets the tint of the color used to fill shapes.
   * 
   * @method fillTint
   * @param  {Number} tint Number from 0 to 100
   *&#x2F;
  pub.fillTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currFillTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Sets the tint of the color used to draw lines and borders around shapes.
   * 
   * @method strokeTint
   * @param  {Number} tint Number from 0 to 100
   *&#x2F;
  pub.strokeTint = function (tint) {
    if (typeof tint === &#x27;string&#x27; || typeof tint === &#x27;number&#x27;) {
      currStrokeTint = tint;
    } else {
      error(&quot;Not supported type. Please make sure the strokeweight is a number or string&quot;);
    }
  };

  &#x2F;**
   * Creates a new RGB or CMYK color and adds the new color to the document, or gets a color by name from the document
   *
   * @method color
   * @param  {String|Numbers} Get color: the color name. Create new color: R,G,B,name or C,M,Y,K,name or Grey,name. Name is always optional
   * @return {Color} found or new color
   *&#x2F;
  pub.color = function() {
    var newCol = null;
    var props = {};
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4];
    if (arguments.length === 1) {
      if (typeof a === &#x27;string&#x27;) {
        try {
          newCol = currentDoc().swatches.item(a);
          newCol.name;
        } catch (e) {
          error(&quot;Color doesn&#x27;t exist. &quot;+e);
        }
        return newCol;
      } else if (typeof a === &#x27;number&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [0,0,0,a];
        props.name = &quot;C=&quot;+0+&quot; M=&quot;+0+&quot; Y=&quot;+0+&quot; K=&quot;+a;
      } else {
        error(&quot;Color doesn&#x27;t exist.&quot;);
      }

    } else if (arguments.length === 2) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [0,0,0,a];
      props.name = b;

    } else if (arguments.length === 3) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.RGB;
      props.colorValue = [a,b,c];
      props.name = &quot;R=&quot;+a+&quot; G=&quot;+b+&quot; B=&quot;+c;

    } else if (arguments.length === 4) {
      if (typeof d === &#x27;string&#x27;) {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.RGB;
        props.colorValue = [a,b,c];
        props.name = d;
      } else {
        props.model = ColorModel.PROCESS;
        props.space = ColorSpace.CMYK;
        props.colorValue = [a,b,c,d];
        props.name = &quot;C=&quot;+a+&quot; M=&quot;+b+&quot; Y=&quot;+c+&quot; K=&quot;+d;
      }

    } else if (arguments.length === 5) {
      props.model = ColorModel.PROCESS;
      props.space = ColorSpace.CMYK;
      props.colorValue = [a,b,c,d];
      props.name = e;

    } else {
      error(&quot;Wrong parameters. Use: &quot;
        + &quot;R,G,B,name or &quot;
        + &quot;C,M,Y,K,name. &quot;
        + &quot;Grey,name &quot;
        + &quot;Name is optional&quot;);
    }

    &#x2F;&#x2F; check whether color was already created and added to swatches,
    &#x2F;&#x2F; keeps the document clean ...
    try {
      var col = currentDoc().swatches.item(props.name);
      col.name;
      col.properties = props;
      return col;
    } catch (e) {
      newCol = currentDoc().colors.add();
      newCol.properties = props;
      return newCol;
    }
  };

  &#x2F;**
   * Calculates a color or colors between two color at a specific increment. 
   * The amt parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
   * N.B.: Both color must be either CMYK or RGB.
   * 
   * @method lerpColor
   * @param  {Color} c1   Input color 1
   * @param  {Color} c2   Input color 2
   * @param  {Number} amt The Amount to interpolate between the two colors
   * @return {Color} Interpolated color
   *&#x2F;
  pub.lerpColor = function (c1, c2, amt) {
    if (c1 instanceof Color &amp;&amp; c2 instanceof Color &amp;&amp; typeof amt === &#x27;number&#x27;) {
      if (c1.space === ColorSpace.CMYK &amp;&amp; c2.space === ColorSpace.CMYK) {
        var C1 = c1.colorValue[0];
        var M1 = c1.colorValue[1];
        var Y1 = c1.colorValue[2];
        var K1 = c1.colorValue[3];

        var C2 = c2.colorValue[0];
        var M2 = c2.colorValue[1];
        var Y2 = c2.colorValue[2];
        var K2 = c2.colorValue[3];

        var COut = Math.round( pub.lerp(C1,C2,amt) );
        var MOut = Math.round( pub.lerp(M1,M2,amt) );
        var YOut = Math.round( pub.lerp(Y1,Y2,amt) );
        var KOut = Math.round( pub.lerp(K1,K2,amt) );
        return pub.color(COut,MOut,YOut,KOut);

      } else if (c1.space === ColorSpace.RGB &amp;&amp; c2.space === ColorSpace.RGB) {
        var R1 = c1.colorValue[0];
        var G1 = c1.colorValue[1];
        var B1 = c1.colorValue[2];

        var R2 = c2.colorValue[0];
        var G2 = c2.colorValue[1];
        var B2 = c2.colorValue[2];

        var ROut = Math.round( pub.lerp(R1,R2,amt) );
        var GOut = Math.round( pub.lerp(G1,G2,amt) );
        var BOut = Math.round( pub.lerp(B1,B2,amt) );
        warning([ROut,GOut,BOut]);
        return pub.color(ROut,GOut,BOut);

      } else {
        error(&quot;Both color must be either CMYK or RGB.&quot;);
      }
    } else {
      error(&quot;Wrong parameters. Use: two colors (of the same type) and a number.&quot;);
    }
  };

  
  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Typography
  
  &#x2F;**
   * Creates a text frame on the current layer on the current page in the current document. 
   * The text frame gets created in the position specified by the x and y parameters.
   * The default document font will be used unless a font is set with the textFont() function. 
   * The default document font size will be used unless a font size is set with the textSize() function. 
   * Change the color of the text with the fill() function.
   * The text displays in relation to the textAlign() and textYAlign() functions. 
   * The width and height parameters define a rectangular area.
   * 
   * @method text
   * @param  {String} txt The text content to set in the text frame.
   * @param  {Number} x   x-coordinate of text frame
   * @param  {Number} y   y-coordinate of text frame
   * @param  {Number} w   width of text frame
   * @param  {Number} h   height of text frame
   * @return {TextFrame}  The created text frame instance
   *&#x2F;
  pub.text = function(txt, x, y, w, h) {
    if (arguments.length !== 5) error(&quot;Not enough parameters to draw a text! Use: txt, x, y, w, h&quot;);
    var textFrame = currentPage().textFrames.add( currentLayer() );
    with (textFrame) {
      contents = txt;
      geometricBounds = [y, x, (y+h), (x+w)];
      textFramePreferences.verticalJustification = currYAlign;
    }
    pub.typo(textFrame, {
      &#x27;appliedFont&#x27;: currFont,
      &#x27;pointSize&#x27;: currFontSize,
      &#x27;fillColor&#x27;: currFillColor,
      &#x27;justification&#x27;: currAlign,
      &#x27;leading&#x27;: currLeading,
      &#x27;kerningValue&#x27;: currKerning,
      &#x27;tracking&#x27;: currTracking
    });

    
    if (currAlign === Justification.CENTER_ALIGN || currAlign === Justification.CENTER_JUSTIFIED) {
      textFrame.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      textFrame.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    }

    return textFrame;
  };

  &#x2F;**
   * Sets text properties to the given item. If the item is not an instance the text property can be set to,
   * the property gets set to the direct descendants of the given item, e.g. all stories of a given document.
   *
   * If no value is given and the given property is a string, the function acts as a getter and returns the
   * corresponding value(s) in an array. This can either be an array containing the value of the concrete item
   * (e.g. character) the values of the item&#x27;s descendants (e.g. paragraphs of given text frame).
   *
   * @method typo
   * @param  {Document|Spread|Page|Layer|Story|TextFrame|Text} item  The object to apply the property to.
   * @param  {String|Object} property  The text property name of an object of key&#x2F;value property&#x2F;value pairs.
   *                                   If property is a string and no value is given, the function acts as getter.
   * @param  {String|Number} [value]   The value to apply to the property.
   * @return {String[]|Number[]}  The property value(s) if the function acts as getter or the items the property
   *                              was assigned to.
   *&#x2F;
  pub.typo = function(item, property, value) {
    var result = [],
      actsAsGetter = typeof property === &#x27;string&#x27; &amp;&amp; (typeof value === undef || value === null),
      getOrSetProperties = function(textItem) {
        if (actsAsGetter) {
          result.push(textItem[prop]);
        } else {
          setProperties(textItem);
        }
      },
      setProperties = function(textItem) {
        if (typeof property === &#x27;string&#x27;) {
          result.push(textItem);
          setProperty(textItem, property, value);
        } else if (typeof property === &#x27;object&#x27;) {
          result.push(textItem);
          for (var prop in property) {
            setProperty(textItem, prop, property[prop]);
          }
        }
      },
      setProperty = function(textItem, prop, val) {
        textItem[prop] = val;
      };

    if (item instanceof Document ||
        item instanceof Spread ||
        item instanceof Page ||
        item instanceof Layer) {
      forEach(item.textFrames, function(textFrame) {
        pub.typo(textFrame, property, value);
      });
    } else if (item instanceof Story ||
               item instanceof TextFrame) {
      forEach(item.paragraphs, function(para) {
        getOrSetProperties(para);
      });
    } else if (isText(item)) {
      getOrSetProperties(item);
    }
    return result;
  };

  &#x2F;**
   * Returns the current font and sets it if argument fontName is given.
   *
   * @method textFont
   * @param  {String} [fontName] The name of the font to set e.g. Helvetica
   * @param  {String} [fontStyle] The Font style e.g. Bold
   * @return {String}            The name of the current font
   *&#x2F;
  pub.textFont = function(fontName, fontStyle) {
    if (arguments.length === 1) {
      currFont = fontName;
    }
    if (arguments.length === 2) {
      currFont = fontName+&quot;\t&quot;+fontStyle;
    }
    return currFont;
  };

  &#x2F;**
   * Returns the current font size in points and sets it if argument pointSize is given.
   *
   * @method textSize
   * @param  {Number} [pointSize] The size in points to set.
   * @return {Number}             The current point size.
   *&#x2F;
  pub.textSize = function(pointSize) {
    if (arguments.length === 1) {
      currFontSize = pointSize;
    }
    return currFontSize;
  };

  &#x2F;**
   * Sets the current horizontal and vertical text alignment.
   *
   * @method textAlign
   * @param  {String} align    The horizontal text alignment to set. Must be one of the InDesign Justification enum values:
   *                           Justification.AWAY_FROM_BINDING_SIDE
   *                           Justification.CENTER_ALIGN
   *                           Justification.CENTER_JUSTIFIED
   *                           Justification.FULLY_JUSTIFIED
   *                           Justification.LEFT_ALIGN
   *                           Justification.RIGHT_ALIGN
   *                           Justification.RIGHT_JUSTIFIED
   *                           Justification.TO_BINDING_SIDE
   * @param  {String} [yAlign] The vertical text alignment to set. Must be one of the InDesign VerticalJustification enum values:
   *                           VerticalJustification.BOTTOM_ALIGN
   *                           VerticalJustification.CENTER_ALIGN
   *                           VerticalJustification.JUSTIFY_ALIGN
   *                           VerticalJustification.TOP_ALIGN
   *&#x2F;
  pub.textAlign = function(align, yAlign) {
    currAlign = align;
    if (arguments.length === 2) currYAlign = yAlign;
  };

  &#x2F;**
   * Returns the spacing between lines of text in units of points and sets it if argument leading is given.
   *
   * @method textLeading
   * @param  {Number|String} [leading] The spacing between lines of text in units of points or the default Indesign enum
   *                                   value Leading.AUTO.
   * @return {Number|String}           The current leading.
   *&#x2F;
  pub.textLeading = function(leading) {
    if (arguments.length === 1) {
      currLeading = leading;
    }
    return currLeading;
  };

  &#x2F;**
   * Returns the current kerning and sets it if argument kerning is given.
   *
   * @method textKerning
   * @param  {Number} [kerning] The value to set.
   * @return {Number}           The current kerning.
   *&#x2F;
  pub.textKerning = function(kerning) {
    if (arguments.length === 1) {
      currKerning = kerning;
    }
    return currKerning;
  };

  &#x2F;**
   * Returns the current tracking and sets it if argument tracking is given.
   *
   * @method textTracking
   * @param  {Number} [tracking] The value to set.
   * @return {Number}            The current tracking.
   *&#x2F;
  pub.textTracking = function(tracking) {
    if (arguments.length === 1) {
      currTracking = tracking;
    }
    return currTracking;
  };

  &#x2F;**
   * Returns the character style with the given name. If the style does not exist it gets created.
   *
   * @method characterStyle
   * @param  {String} name      The name of the character style to return.
   * @return {CharachterStyle}  The character style instance.
   *&#x2F;
  pub.characterStyle = function(name) {
    var style = null;
    try {
      style = currentDoc().characterStyles.item(name);
      style.name;
    } catch (e) {
      style = currentDoc().characterStyles.add({name: name});
    }
    return style;
  };

  &#x2F;**
   * Returns the paragraph style with the given name. If the style does not exist it gets created.
   *
   * @method paragraphStyle
   * @param  {String} name     The name of the paragraph style to return.
   * @return {ParagraphStyle}  The paragraph style instance.
   *&#x2F;
  pub.paragraphStyle = function(name) {
    var style = null;
    try {
      style = currentDoc().paragraphStyles.item(name);
      style.name;
    } catch (e) {
      style = currentDoc().paragraphStyles.add({name: name});
    }
    return style;
  };

  &#x2F;**
   * Links the stories of two textframes to one story. Text of first textframe overflows to second one.
   *
   * @method linkTextFrames
   * @param  {TextFrame} textFrameA
   * @param  {TextFrame} textFrameB
   *&#x2F;
  pub.linkTextFrames = function (textFrameA, textFrameB) {
    if (textFrameA instanceof TextFrame &amp;&amp; textFrameB instanceof TextFrame) {
      textFrameA.nextTextFrame = textFrameB;
    } else {
      error(&quot;Wrong type! linkTextFrames() needs two textFrame objects to link the stories. Use: textFrameA, textFrameB&quot;);
    }
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Image
  
  &#x2F;**
   * Adds an image to the document. If the image argument is given as a string the image file  must be in the document&#x27;s
   * data directory which is in the same directory where the document is saved in. The image argument can also be a File
   * instance which can be placed even before the document was saved.
   * The second argument can either be the x position of the frame to create or an instance of a rectangle,
   * oval or polygon to place the image in.
   * If x and y positions are given and width and height are not given, the frame&#x27;s size gets set to the original image size.
   *
   * @method image
   * @param  {String|File} img The image file name in the document&#x27;s data directory or a File instance
   * @param  {Number|Rectangle|Oval|Polygon} x The x position on the current page or the item instance to place the image in
   * @param  {Number} [y] The y position on the current page. Ignored if x is not a number.
   * @param  {Number} [w] The width of the rectangle to add the image to. Ignored if x is not a number.
   * @param  {Number} [h] The height of the rectangle to add the image to. Ignored if x is not a number.
   * @return {Rectangle|Oval|Polygon} The item instance the image was placed in.
   *&#x2F;
  pub.image = function(img, x, y, w, h) {
    var file = initDataFile(img, true),
      frame = null,
      fitOptions = null,
      width = null,
      height = null;
    if (x instanceof Rectangle ||
        x instanceof Oval ||
        x instanceof Polygon) {
      frame = x;
    } else {
      width = 1;
      height = 1;
      if (currImageMode === pub.CORNERS) {
        width = w - x;
        height = h - y;
        fitOptions = FitOptions.contentToFrame;
      } else {
        if (w &amp;&amp; h) {
          width = w;
          height = h;
          fitOptions = FitOptions.contentToFrame;
        } else {
          fitOptions = FitOptions.frameToContent;
        }
      }
      
      frame = currentPage().rectangles.add({
        geometricBounds:[y, x, y + height, x + width]
      });
    }
    
    frame.place(file);

    if (fitOptions) {
      frame.fit(fitOptions);
    }

    if (currImageMode === pub.CENTER) {
      var bounds = frame.geometricBounds;
      width = bounds[3] - bounds[1];
      height = bounds[2] - bounds[0];
      frame.move(null, [-(width &#x2F; 2), -(height &#x2F; 2)]);
      frame.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                         AnchorPoint.CENTER_ANCHOR,
                         currMatrix.adobeMatrix() );
    } else {
      frame.transform(CoordinateSpaces.PASTEBOARD_COORDINATES,
                     AnchorPoint.TOP_LEFT_ANCHOR,
                     currMatrix.adobeMatrix() );
    }
    return frame;
  };

  &#x2F;**
   * Transforms position and size of an image.
   * The image fit options are always &quot;contentToFrame&quot;.
   *
   * @method transformImage
   * @param  {Graphic} img The image to transform
   * @param  {Number} x       New x
   * @param  {Number} y       New y
   * @param  {Number} width   New width
   * @param  {Number} height  New height
   *&#x2F;
  pub.transformImage = function(img, x, y, width, height) {
    if (img.hasOwnProperty(&quot;geometricBounds&quot;) &amp;&amp; img.hasOwnProperty(&quot;fit&quot;)) {
      &#x2F;&#x2F;[y1, x1, y2, x2]
      img.geometricBounds = [y,x,y+height,x+width];
      if (currImageMode === pub.CENTER) {
        img.move(null, [-(width &#x2F; 2), -(height &#x2F; 2)]);
      }
      img.fit( FitOptions.CENTER_CONTENT );
      img.fit( FitOptions.contentToFrame );
    } else {
      error(&quot;transformImage(). Wrong type! Use: img, x, y, width, height&quot;);
    }
  };

  &#x2F;* todo *&#x2F;
  pub.imageMode = function(mode) {
    if (arguments.length === 0) return currImageMode;

    if (mode === pub.CORNER || mode === pub.CORNERS || mode === pub.CENTER ) {
      currImageMode = mode;
    } else {
      error(&quot;Unsupported imageMode. Use: CORNER, CORNERS, CENTER.&quot;);
    }
    return currImageMode;
  };

  var initDataFile = function(file, mustExist) {
    var result = null;
    if (file instanceof File) {
      result = file;
    } else {
      var folder = new Folder(projectPath().absoluteURI + &#x27;&#x2F;data&#x27;);
      folder.create(); &#x2F;&#x2F; creates data folder if not existing, otherwise it just skips
      result = new File(folder.absoluteURI + &#x27;&#x2F;&#x27; + file);
    }
    if (mustExist &amp;&amp; !result.exists) {
      error(&#x27;The file &quot;&#x27; + result + &#x27;&quot; does not exist.&#x27;);
    }
    return result;
  };
  
  var initExportFile = function(file, mustExist) {
    var result = null;
    if (file instanceof File) {
      result = file;
    } else {
      result = new File(projectPath().absoluteURI + &#x27;&#x2F;&#x27; + file);
    }
    if (mustExist &amp;&amp; !result.exists) {
      error(&#x27;The file &quot;&#x27; + result + &#x27;&quot; does not exist.&#x27;);
    }
    return result;
  };
  
  var projectPath = function() {
      var docPath = null;
      try {
        docPath = currentDoc().filePath;
      } catch (e) {
        error(&quot;The current document must be saved before its project directory can be accessed.&quot;);
      }
      return docPath;
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Math
  
  &#x2F;* todo *&#x2F;
  var PVector = pub.PVector = function() {
    function PVector(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    PVector.dist = function(v1, v2) {
      return v1.dist(v2);
    };
    PVector.dot = function(v1, v2) {
      return v1.dot(v2);
    };
    PVector.cross = function(v1, v2) {
      return v1.cross(v2);
    };
    PVector.angleBetween = function(v1, v2) {
      return Math.acos(v1.dot(v2) &#x2F; (v1.mag() * v2.mag()));
    };
    PVector.prototype = {
      set: function(v, y, z) {
        if (arguments.length === 1) this.set(v.x || v[0] || 0, v.y || v[1] || 0, v.z || v[2] || 0);
        else {
          this.x = v;
          this.y = y;
          this.z = z;
        }
      },
      get: function() {
        return new PVector(this.x, this.y, this.z);
      },
      mag: function() {
        var x = this.x,
          y = this.y,
          z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      },
      add: function(v, y, z) {
        if (arguments.length === 1) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
        } else {
          this.x += v;
          this.y += y;
          this.z += z;
        }
      },
      sub: function(v, y, z) {
        if (arguments.length === 1) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
        } else {
          this.x -= v;
          this.y -= y;
          this.z -= z;
        }
      },
      mult: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x *= v;
          this.y *= v;
          this.z *= v;
        } else {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
        }
      },
      div: function(v) {
        if (typeof v === &quot;number&quot;) {
          this.x &#x2F;= v;
          this.y &#x2F;= v;
          this.z &#x2F;= v;
        } else {
          this.x &#x2F;= v.x;
          this.y &#x2F;= v.y;
          this.z &#x2F;= v.z;
        }
      },
      dist: function(v) {
        var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      },
      dot: function(v, y, z) {
        if (arguments.length === 1) return this.x * v.x + this.y * v.y + this.z * v.z;
        return this.x * v + this.y * y + this.z * z;
      },
      cross: function(v) {
        var x = this.x,
          y = this.y,
          z = this.z;
        return new PVector(y * v.z - v.y * z, z * v.x - v.z * x, x * v.y - v.x * y);
      },
      normalize: function() {
        var m = this.mag();
        if (m &gt; 0) this.div(m);
      },
      limit: function(high) {
        if (this.mag() &gt; high) {
          this.normalize();
          this.mult(high);
        }
      },
      heading2D: function() {
        return -Math.atan2(-this.y, this.x);
      },
      toString: function() {
        return &quot;[&quot; + this.x + &quot;, &quot; + this.y + &quot;, &quot; + this.z + &quot;]&quot;;
      },
      array: function() {
        return [this.x, this.y, this.z];
      }
    };

    function createPVectorMethod(method) {
      return function(v1, v2) {
        var v = v1.get();
        v[method](v2);
        return v;
      };
    }
    for (var method in PVector.prototype) if (PVector.prototype.hasOwnProperty(method) &amp;&amp; !PVector.hasOwnProperty(method)) PVector[method] = createPVectorMethod(method);
    return PVector;
  }();
  

  &#x2F;&#x2F; -- Calculation --
  &#x2F;* todo *&#x2F;
  pub.abs = Math.abs;

  &#x2F;* todo *&#x2F;
  pub.ceil = Math.ceil;

  &#x2F;* todo *&#x2F;
  pub.constrain = function(aNumber, aMin, aMax) {
    return aNumber &gt; aMax ? aMax : aNumber &lt; aMin ? aMin : aNumber;
  };

  &#x2F;* todo *&#x2F;
  pub.dist = function() {
    var dx, dy, dz;
    if (arguments.length === 4) {
      dx = arguments[0] - arguments[2];
      dy = arguments[1] - arguments[3];
      return Math.sqrt(dx * dx + dy * dy);
    }
  };

  &#x2F;* todo *&#x2F;
  pub.exp = Math.exp;
  &#x2F;* todo *&#x2F;
  pub.floor = Math.floor;
  &#x2F;* todo *&#x2F;
  pub.lerp = function(value1, value2, amt) {
    return (value2 - value1) * amt + value1;
  };
  &#x2F;* todo *&#x2F;
  pub.log = Math.log;
  &#x2F;* todo *&#x2F;
  pub.mag = function(a, b, c) {
    if (c) return Math.sqrt(a * a + b * b + c * c);
    return Math.sqrt(a * a + b * b);
  };
  &#x2F;* todo *&#x2F;
  pub.map = function(value, istart, istop, ostart, ostop) {
    return ostart + (ostop - ostart) * ((value - istart) &#x2F; (istop - istart));
  };
  &#x2F;* todo *&#x2F;
  pub.max = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[1] : arguments[0];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var max = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (max &lt; numbers[i]) max = numbers[i];
    return max;
  };
  &#x2F;* todo *&#x2F;
  pub.min = function() {
    if (arguments.length === 2) return arguments[0] &lt; arguments[1] ? arguments[0] : arguments[1];
    var numbers = arguments.length === 1 ? arguments[0] : arguments;
    if (! (&quot;length&quot; in numbers &amp;&amp; numbers.length &gt; 0)) error(&quot;Non-empty array is expected&quot;);
    var min = numbers[0],
      count = numbers.length;
    for (var i = 1; i &lt; count; ++i) if (min &gt; numbers[i]) min = numbers[i];
    return min;
  };
  &#x2F;* todo *&#x2F;
  pub.norm = function(aNumber, low, high) {
    return (aNumber - low) &#x2F; (high - low);
  };
  &#x2F;* todo *&#x2F;
  pub.pow = Math.pow;
  &#x2F;* todo *&#x2F;
  pub.round = Math.round;
  &#x2F;* todo *&#x2F;
  pub.sq = function(aNumber) {
    return aNumber * aNumber;
  };

  &#x2F;&#x2F; -- Trigonometry --
  &#x2F;* todo *&#x2F;
  pub.sqrt = Math.sqrt;
  pub.acos = Math.acos;
  pub.asin = Math.asin;
  pub.atan = Math.atan;
  pub.atan2 = Math.atan2;
  pub.cos = Math.cos;
  &#x2F;* todo *&#x2F;
  pub.degrees = function(aAngle) {
    return aAngle * 180 &#x2F; Math.PI;
  };
  &#x2F;* todo *&#x2F;
  pub.radians = function(aAngle) {
    return aAngle &#x2F; 180 * Math.PI;
  };
  &#x2F;* todo *&#x2F;
  pub.sin = Math.sin;
  pub.tan = Math.tan;

  &#x2F;&#x2F; -- Random --
  
  var currentRandom = Math.random;
  &#x2F;* todo *&#x2F;
  pub.random = function() {
    if (arguments.length === 0) return currentRandom();
    if (arguments.length === 1) return currentRandom() * arguments[0];
    var aMin = arguments[0],
      aMax = arguments[1];
    return currentRandom() * (aMax - aMin) + aMin;
  };

  function Marsaglia(i1, i2) {
    var z = i1 || 362436069,
      w = i2 || 521288629;
    var nextInt = function() {
      z = 36969 * (z &amp; 65535) + (z &gt;&gt;&gt; 16) &amp; 4294967295;
      w = 18E3 * (w &amp; 65535) + (w &gt;&gt;&gt; 16) &amp; 4294967295;
      return ((z &amp; 65535) &lt;&lt; 16 | w &amp; 65535) &amp; 4294967295;
    };
    this.nextDouble = function() {
      var i = nextInt() &#x2F; 4294967296;
      return i &lt; 0 ? 1 + i : i;
    };
    this.nextInt = nextInt;
  }
  Marsaglia.createRandomized = function() {
    var now = new Date();
    return new Marsaglia(now &#x2F; 6E4 &amp; 4294967295, now &amp; 4294967295);
  };
  &#x2F;* todo *&#x2F;
  pub.randomSeed = function(seed) {
    currentRandom = (new Marsaglia(seed)).nextDouble;
  };
  &#x2F;* todo *&#x2F;
  pub.Random = function(seed) {
    var haveNextNextGaussian = false,
      nextNextGaussian, random;
    this.nextGaussian = function() {
      if (haveNextNextGaussian) {
        haveNextNextGaussian = false;
        return nextNextGaussian;
      }
      var v1, v2, s;
      do {
        v1 = 2 * random() - 1;
        v2 = 2 * random() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s &gt;= 1 || s === 0);
      var multiplier = Math.sqrt(-2 * Math.log(s) &#x2F; s);
      nextNextGaussian = v2 * multiplier;
      haveNextNextGaussian = true;
      return v1 * multiplier;
    };
    random = seed === undef ? Math.random : (new Marsaglia(seed)).nextDouble;
  };

  &#x2F;* todo *&#x2F;
  function PerlinNoise(seed) {
    var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();
    var i, j;
    var perm = new Uint8Array(512);
    for (i = 0; i &lt; 256; ++i) perm[i] = i;
    for (i = 0; i &lt; 256; ++i) {
      var t = perm[j = rnd.nextInt() &amp; 255];
      perm[j] = perm[i];
      perm[i] = t;
    }
    for (i = 0; i &lt; 256; ++i) perm[i + 256] = perm[i];
    
    function grad3d(i, x, y, z) {
      var h = i &amp; 15;
      var u = h &lt; 8 ? x : y,
      v = h &lt; 4 ? y : h === 12 || h === 14 ? x : z;
      return ((h &amp; 1) === 0 ? u : -u) + ((h &amp; 2) === 0 ? v : -v);
    }
    
    function grad2d(i, x, y) {
      var v = (i &amp; 1) === 0 ? x : y;
      return (i &amp; 2) === 0 ? -v : v;
    }
    
    function grad1d(i, x) {
      return (i &amp; 1) === 0 ? -x : x;
    }
    function lerp(t, a, b) {
      return a + t * (b - a);
    }
    &#x2F;* noise3d *&#x2F;
    this.noise3d = function(x, y, z) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255,
        Z = Math.floor(z) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y,
        fz = (3 - 2 * z) * z * z;
      var p0 = perm[X] + Y,
        p00 = perm[p0] + Z,
        p01 = perm[p0 + 1] + Z,
        p1 = perm[X + 1] + Y,
        p10 = perm[p1] + Z,
        p11 = perm[p1 + 1] + Z;
      return lerp(fz, lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)), lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))), lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)), lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))));
    };
    &#x2F;* todo *&#x2F;
    this.noise2d = function(x, y) {
      var X = Math.floor(x) &amp; 255,
        Y = Math.floor(y) &amp; 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      var fx = (3 - 2 * x) * x * x,
        fy = (3 - 2 * y) * y * y;
      var p0 = perm[X] + Y,
        p1 = perm[X + 1] + Y;
      return lerp(fy, lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)), lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1)));
    };
    &#x2F;* todo *&#x2F;
    this.noise1d = function(x) {
      var X = Math.floor(x) &amp; 255;
      x -= Math.floor(x);
      var fx = (3 - 2 * x) * x * x;
      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X + 1], x - 1));
    };
  }
  var noiseProfile = {
    generator: undef,
    octaves: 4,
    fallout: 0.5,
    seed: undef
  };
  &#x2F;* todo *&#x2F;
  pub.noise = function(x, y, z) {
    if (noiseProfile.generator === undef) noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
    var generator = noiseProfile.generator;
    var effect = 1,
      k = 1,
      sum = 0;
    for (var i = 0; i &lt; noiseProfile.octaves; ++i) {
      effect *= noiseProfile.fallout;
      switch (arguments.length) {
      case 1:
        sum += effect * (1 + generator.noise1d(k * x)) &#x2F; 2;
        break;
      case 2:
        sum += effect * (1 + generator.noise2d(k * x, k * y)) &#x2F; 2;
        break;
      case 3:
        sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) &#x2F; 2;
        break;
      }
      k *= 2;
    }
    return sum;
  };
  &#x2F;* todo *&#x2F;
  pub.noiseDetail = function(octaves, fallout) {
    noiseProfile.octaves = octaves;
    if (fallout !== undef) noiseProfile.fallout = fallout;
  };
  &#x2F;* todo *&#x2F;
  pub.noiseSeed = function(seed) {
    noiseProfile.seed = seed;
    noiseProfile.generator = undef;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Input
  &#x2F;* todo *&#x2F;
  pub.year = function() {
    return (new Date()).getFullYear()();
  };
  &#x2F;* todo *&#x2F;
  pub.month = function() {
    return (new Date()).getMonth() + 1;
  };
  &#x2F;* todo *&#x2F;
  pub.day = function() {
    return (new Date()).getDate();
  };
  &#x2F;* todo *&#x2F;
  pub.hour = function() {
    return (new Date()).getHours();
  };
  &#x2F;* todo *&#x2F;
  pub.minute = function() {
    return (new Date()).getMinutes();
  };
  &#x2F;* todo *&#x2F;
  pub.second = function() {
    return (new Date()).getSeconds();
  };
  &#x2F;* todo *&#x2F;
  pub.millis = function() {
    return Date.now() - start;
  };

  &#x2F;**
   * Returns items tagged with the given label in the InDesign Script Label pane (Window -&gt; Utilities -&gt; Script Label).
   *
   * @method findByLabel
   * @param  {String} label The label identifier
   * @return {PageItem[]} Array of concrete PageItem instances, e.g. TextFrame or SplineItem.
   *&#x2F;
  pub.findByLabel = function(label) {
    var result = [];
    var doc = currentDoc();
    for (var i = 0, len = doc.pageItems.length; i &lt; len; i++) {
      var pageItem = doc.pageItems[i];
      if (pageItem.label === label) {
        &#x2F;&#x2F; push pageItem&#x27;s 1st element to get the concrete PageItem instance, e.g. a TextFrame
        result.push(pageItem.getElements()[0]);
      }
    }
    return result;
  };

  &#x2F;**
   * Returns the currently selected object(s)
   *
   * @method selection
   * @return {Object[]} Array of selected object(s).
   *&#x2F;
  pub.selection = function() {
    return app.selection;
  };

  &#x2F;**
   * Reads the contents of a file and creates a String array of its individual lines.
   * If the file is specified by name as String, it must be located in the document&#x27;s data directory.
   *
   * @method loadStrings
   * @param  {String|File} file The text file name in the document&#x27;s data directory or a File instance
   * @return {String[]}  Array of the individual lines in the given file.
   *&#x2F;
  pub.loadStrings = function(file) {
    var inputFile = initDataFile(file, true),
      result = [];

    inputFile.open(&#x27;r&#x27;);
    while (!inputFile.eof) {
      result.push(inputFile.readln());
    }
    inputFile.close();

    return result;
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Output
  
  &#x2F;* todo *&#x2F;
  var println = pub.println = function(msg) {
    $.writeln(msg);
  };

  &#x2F;* todo *&#x2F;
  pub.print = function(msg) {
    $.write(msg);
  };

  &#x2F;**
   * Writes an array of strings to a file, one line per string. This file is saved to the document&#x27;s data directory.
   * If the given file exists it gets overridden.
   *
   * @method saveStrings
   * @param  {String|File} file The file name or a File instance
   * @param  {String[]} strings The string array to be written
   *&#x2F;
  pub.saveStrings = function(file, strings) {
    var outputFile = initExportFile(file);
    outputFile.open(&#x27;w&#x27;);
    forEach(strings, function(s) {
      outputFile.writeln(s);
    });
    outputFile.close();
  };

  &#x2F;**
   * Exports the current document as PDF to the documents data folder. Please note, that export options default to the last used export settings.
   *
   * @todo data folder is not created automatically,
   * @method savePDF
   * @param {String|File} file The file name or a File instance
   * @param {Boolean} showOptions Whether to show the export dialog
   *&#x2F;
  pub.savePDF = function(file, showOptions){
    var outputFile = initExportFile(file);
    if (typeof showOptions !== &quot;boolean&quot;) showOptions = false;
    b.doc().exportFile(ExportFormat.PDF_TYPE, outputFile, showOptions);
  };
  

  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; Transform
  &#x2F;&#x2F; geometricBounds hint: [y1, x1, y2, x2]

  &#x2F;**
   * Positions a PageItem at the designated spot on the x axis. If no x argument is given the current x position is returned.
   *
   * @method itemX
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [x] The new x position
   * @returns {Number} The current x position
   *&#x2F;
  pub.itemX = function(pItem, x) {
    if(pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
      if( x !== null ){
        b.itemPosition(pItem, x, pItem.geometricBounds[0]);
      } else {
        return pItem.geometricBounds[1];
      }
    } else {
      error(&quot;pItem has to be a valid PageItem&quot;);
    }
  };

  &#x2F;**
   * Positions a PageItem at the designated spot on the y axis. If no y argument is given the current y position is returned.
   *
   * @method itemY
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [y] The new y position
   * @returns {Number} The current y position
   *&#x2F;
  pub.itemY = function(pItem, y) {
    if(pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
      if( y !== null ) {
        b.itemPosition(pItem, pItem.geometricBounds[1], y);
      } else {
        return pItem.geometricBounds[0];
      }
    } else {
      error(&quot;pItem has to be a valid PageItem&quot;);
    }
  };
  
  &#x2F;**
   * Scales the given PageItem to the given width. If width is not given as argument the current width is returned.
   *
   * @method itemWidth
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [width] The new width
   * @returns {Number} The current width
   *&#x2F;
  pub.itemWidth = function(pItem, width) {
    if(pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
      if( width !== null ){
        b.itemSize( pItem, width, Math.abs(pItem.geometricBounds[2] - pItem.geometricBounds[0]) );
      } else {
        return Math.abs(pItem.geometricBounds[3] - pItem.geometricBounds[1]);
      }
    } else {
      error(&quot;pItem has to be a valid PageItem&quot;);
    }
  };

  &#x2F;**
   * Scales the given PageItem to the given height. If height is not given as argument the current height is returned.
   *
   * @method itemHeight
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [height] The new height
   * @returns {Number} The current height
   *&#x2F;
  pub.itemHeight = function(pItem, height) {
    if(pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
      if( height !== null ){
        b.itemSize( pItem, Math.abs(pItem.geometricBounds[3] - pItem.geometricBounds[1]), height );
      } else {
        return Math.abs(pItem.geometricBounds[2] - pItem.geometricBounds[0]);
      }
    } else {
      error(&quot;pItem has to be a valid PageItem&quot;);
    }
  };

  &#x2F;**
   * Moves the given PageItem to the given position. If x or y is not given as argument the current position is returned.
   *
   * @method itemPosition
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [x] The new x coordinate
   * @param {Number} [y] The new y coordinate
   * @returns {Object} Returns an object with the fields x and y
   *&#x2F;
  pub.itemPosition = function(pItem, x, y) {
    if (pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
    
      if( x !== null &amp;&amp; y !== null) {
        var width = pItem.geometricBounds[3] - pItem.geometricBounds[1];
        var height = pItem.geometricBounds[2] - pItem.geometricBounds[0];
        pItem.geometricBounds = [ y, x, y + height, x + width ];
      } else {
        return { x: pItem.geometricBounds[1], y: pItem.geometricBounds[0] };
      }
      
    } else {
      error(&quot;itemPosition() only works with child classes of PageItem.&quot;);
    }
  };

  &#x2F;**
   * Scales the given PageItem to the given size. If width or height is not given as argument the current size is returned.
   *
   * @method itemSize
   * @param {PageItem} pItem The PageItem to alter
   * @param {Number} [width] The new width
   * @param {Number} [height] The new height
   * @returns {Object} Returns an object with the fields width and height
   *&#x2F;
  pub.itemSize = function(pItem, width, height) {
    if (pItem !== null &amp;&amp; pItem.hasOwnProperty(&quot;geometricBounds&quot;)) {
    
      if( width !== null &amp;&amp; height !== null ) {
        var x = pItem.geometricBounds[1];
        var y = pItem.geometricBounds[0];
        pItem.geometricBounds = [ y, x, y + height, x + width ];
      } else {
        return { width: pItem.geometricBounds[3] - pItem.geometricBounds[1] , height: pItem.geometricBounds[2] - pItem.geometricBounds[0] };
      }
      
    } else {
      error(&quot;itemSize() only works with child classes of PageItem.&quot;);
    }
  };
  
  
  var printMatrixHelper = function(elements) {
    var big = 0;
    for (var i = 0; i &lt; elements.length; i++) if (i !== 0) big = Math.max(big, Math.abs(elements[i]));
    else big = Math.abs(elements[i]);
    var digits = (big + &quot;&quot;).indexOf(&quot;.&quot;);
    if (digits === 0) digits = 1;
    else if (digits === -1) digits = (big + &quot;&quot;).length;
    return digits;
  };

  var PMatrix2D = pub.PMatrix2D = function() {
    if (arguments.length === 0) this.reset();
    else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) this.set(arguments[0].array());
    else if (arguments.length === 6) this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
  };
  PMatrix2D.prototype = {
    set: function() {
      if (arguments.length === 6) {
        var a = arguments;
        this.set([a[0], a[1], a[2], a[3], a[4], a[5]]);
      } else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) this.elements = arguments[0].array();
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) this.elements = arguments[0].slice();
    },
    get: function() {
      var outgoing = new PMatrix2D();
      outgoing.set(this.elements);
      return outgoing;
    },
    reset: function() {
      this.set([1, 0, 0, 0, 1, 0]);
    },
    array: function array() {
      return this.elements.slice();
    },
    adobeMatrix: function array() {
      return [this.elements[0],
              this.elements[3],
              this.elements[1],
              this.elements[4],
              this.elements[2],
              this.elements[5]];
    },
    translate: function(tx, ty) {
      this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
      this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];
    },
    invTranslate: function(tx, ty) {
      this.translate(-tx, -ty);
    },
    transpose: function() {},
    mult: function(source, target) {
      var x, y;
      if (source instanceof PVector) {
        x = source.x;
        y = source.y;
        if (!target) target = new PVector();
      } else if (source instanceof Array) {
        x = source[0];
        y = source[1];
        if (!target) target = [];
      }
      if (target instanceof Array) {
        target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
        target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];
      } else if (target instanceof PVector) {
        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
        target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
        target.z = 0;
      }
      return target;
    },
    multX: function(x, y) {
      return x * this.elements[0] + y * this.elements[1] + this.elements[2];
    },
    multY: function(x, y) {
      return x * this.elements[3] + y * this.elements[4] + this.elements[5];
    },
    &#x2F;*
    &#x2F;&#x2F; BUG, seems to be buggy in processing.js, and i am not clever enough to figure it out
    shearX: function(angle) {
      this.apply(1, 0, 1, Math.tan(angle), 0, 0)
    },
    shearY: function(angle) {
      this.apply(1, 0, 1, 0, Math.tan(angle), 0)
    },*&#x2F;
    determinant: function() {
      return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];
    },
    invert: function() {
      var d = this.determinant();
      if (Math.abs(d) &gt; -2147483648) {
        var old00 = this.elements[0];
        var old01 = this.elements[1];
        var old02 = this.elements[2];
        var old10 = this.elements[3];
        var old11 = this.elements[4];
        var old12 = this.elements[5];
        this.elements[0] = old11 &#x2F; d;
        this.elements[3] = -old10 &#x2F; d;
        this.elements[1] = -old01 &#x2F; d;
        this.elements[4] = old00 &#x2F; d;
        this.elements[2] = (old01 * old12 - old11 * old02) &#x2F; d;
        this.elements[5] = (old10 * old02 - old00 * old12) &#x2F; d;
        return true;
      }
      return false;
    },
    scale: function(sx, sy) {
      if (sx &amp;&amp; !sy) sy = sx;
      if (sx &amp;&amp; sy) {
        this.elements[0] *= sx;
        this.elements[1] *= sy;
        this.elements[3] *= sx;
        this.elements[4] *= sy;
      }
    },
    invScale: function(sx, sy) {
      if (sx &amp;&amp; !sy) sy = sx;
      this.scale(1 &#x2F; sx, 1 &#x2F; sy);
    },
    apply: function() {
      var source;
      if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) source = arguments[0].array();
      else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) source = arguments[0];
      var result = [0, 0, this.elements[2], 0, 0, this.elements[5]];
      var e = 0;
      for (var row = 0; row &lt; 2; row++) for (var col = 0; col &lt; 3; col++, e++) result[e] += this.elements[row * 3 + 0] * source[col + 0] + this.elements[row * 3 + 1] * source[col + 3];
      this.elements = result.slice();
    },
    preApply: function() {
      var source;
      if (arguments.length === 1 &amp;&amp; arguments[0] instanceof PMatrix2D) source = arguments[0].array();
      else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);
      else if (arguments.length === 1 &amp;&amp; arguments[0] instanceof Array) source = arguments[0];
      var result = [0, 0, source[2], 0, 0, source[5]];
      result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];
      result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];
      result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];
      result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];
      result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];
      result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];
      this.elements = result.slice();
    },
    rotate: function(angle) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var temp1 = this.elements[0];
      var temp2 = this.elements[1];
      this.elements[0] = c * temp1 + s * temp2;
      this.elements[1] = -s * temp1 + c * temp2;
      temp1 = this.elements[3];
      temp2 = this.elements[4];
      this.elements[3] = c * temp1 + s * temp2;
      this.elements[4] = -s * temp1 + c * temp2;
    },
    rotateZ: function(angle) {
      this.rotate(angle);
    },
    invRotateZ: function(angle) {
      this.rotateZ(angle - Math.PI);
    },
    print: function() {
      var digits = printMatrixHelper(this.elements);
      var output = &quot;&quot; + pub.nfs(this.elements[0], digits, 4) + &quot; &quot; + pub.nfs(this.elements[1], digits, 4) + &quot; &quot; + pub.nfs(this.elements[2], digits, 4) + &quot;\n&quot; + pub.nfs(this.elements[3], digits, 4) + &quot; &quot; + pub.nfs(this.elements[4], digits, 4) + &quot; &quot; + pub.nfs(this.elements[5], digits, 4) + &quot;\n\n&quot;;
      pub.println(output);
    }
  };

  pub.applyMatrix = function (matrix) {
    currMatrix.apply(matrix);
  };

  pub.popMatrix = function (argument) {
    if (matrixStack.length &gt; 0) {
      currMatrix.set( matrixStack.pop() );
    } else {
      error(&quot;Missing a pushMatrix() to go with that popMatrix()&quot;);
    }
  };

  pub.printMatrix = function (argument) {
    currMatrix.print();
  };

  pub.pushMatrix = function (argument) {
    matrixStack.push( currMatrix.array() );
  };

  pub.resetMatrix = function (argument) {
    matrixStack = [];
    currMatrix = new PMatrix2D();
  };

  pub.rotate = function (angle) {
    currMatrix.rotate(angle);
  };

  pub.scale = function (scaleX,scaleY) {
    currMatrix.scale(scaleX,scaleY);
  };

  pub.translate = function (tx,ty) {
    currMatrix.translate(tx,ty);
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; execution
  
  &#x2F;**
   * Run the sketch! Has to be called in every sketch a the very end of the code.
   *
   * @method go
   *&#x2F;
  pub.go = function() {
    currentDoc();
    runSetup();
    runDrawOnce();
  };

  &#x2F;**
   * EXPERIMENTAL!
   *
   * Causes basil to continuously execute the code within draw() when InDesign is idle.
   * #targetengine &quot;loop&quot;; must be at the very top in the script file.
   * If noLoop() is called, the code in draw() stops executing.
   * It is essential to call noLoop() or execute the script lib&#x2F;stop.jsx when the script is finished!
   * The framerate property determines how often draw() is called per second, e.g. a framerate of 20 will 20times call draw() per second.
   *
   * @method loop
   * @param  {Number} framerate   The framerate per second, determines how often draw() is called per second.
   *&#x2F;
  pub.loop = function(framerate) {
    var sleep = null;
    if (arguments.length === 0) sleep = Math.round(1000&#x2F;25);
    else sleep = Math.round(1000&#x2F;framerate);

    if ($.engineName !== &#x27;loop&#x27;) {
      error(&#x27;Add #targetengine &quot;loop&quot;; at the very top of your script.&#x27;);
    }

    currentDoc();
    runSetup();

    var idleTask = app.idleTasks.add({name: &quot;basil_idle_task&quot;, sleep: sleep});
    idleTask.addEventListener(IdleEvent.ON_IDLE, function() {
      runDrawLoop();
    }, false);
    &#x2F;&#x2F;alert(&quot;Run the script lib&#x2F;stop.jsx to end the draw loop and clean up!&quot;);
    println(&quot;loop()&quot;);
  };

  &#x2F;**
   * EXPERIMENTAL!
   *
   * Stops basil from continuously executing the code within draw().
   *
   * @method noLoop
   *&#x2F;
  pub.noLoop = function() {
    var allIdleTasks = app.idleTasks;
    for (var i = app.idleTasks.length - 1; i &gt;= 0; i--) {
      allIdleTasks[i].remove();
    }
    println(&quot;noLoop()&quot;);
  };


  &#x2F;&#x2F; ----------------------------------------
  &#x2F;&#x2F; all private from here

  var init = function() {
    glob.b = pub;

    welcome();

    &#x2F;&#x2F; -- init internal state vars --
    currStrokeWeight = 1;
    currStrokeTint = 100;
    currFillTint = 100;
  };

  var runSetup = function() {
    app.doScript(function() {
      if (typeof glob.setup === &#x27;function&#x27;) {
        glob.setup();
      }
    }, ScriptLanguage.javascript, undef, UndoModes.entireScript);
  };

  var runDrawOnce = function() {
    app.doScript(function() {
      if (typeof glob.draw === &#x27;function&#x27;) {
        glob.draw();
      }
    }, ScriptLanguage.javascript, undef, UndoModes.entireScript);
  };

  var runDrawLoop = function() {
    app.doScript(function() {
      if (typeof glob.draw === &#x27;function&#x27;) {
        glob.draw();
      }
    }, ScriptLanguage.javascript, undef, UndoModes.fastEntireScript);
  };

  var welcome = function() {
    $.writeln(&quot;basil.js &quot;
        + pub.VERSION
        + &quot; &quot;
        + &quot;infos, feedback @ http:&#x2F;&#x2F;basiljs.ch&quot;);
  };
  
  var currentDoc = function() {
    if (!currDoc) {
      var doc = null;
      try {
        doc = app.activeDocument;
      } catch(e) {
        doc = app.documents.add();
      }
      setCurrDoc(doc);
    }
    return currDoc;
  };

  var setCurrDoc = function(doc) {
    resetCurrDoc();
    currDoc = doc;
    &#x2F;&#x2F; -- setup document --
    currDoc.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;
    currFont = currDoc.textDefaults.appliedFont.name;
    currFontSize = currDoc.textDefaults.pointSize;
    currAlign = currDoc.textDefaults.justification;
    currLeading = currDoc.textDefaults.leading;
    currKerning = 0;
    currTracking = currDoc.textDefaults.tracking;
    pub.units(pub.PT);
    updatePublicPageSizeVars();
  };

  var resetCurrDoc = function() {
    &#x2F;&#x2F; resets doc and doc specific vars
    currDoc = null;
    currPage = null;
    currLayer = null;
    currFillColor = &quot;Black&quot;;
    noneSwatchColor = &quot;None&quot;;
    currStrokeColor = &quot;Black&quot;;
    currRectMode = pub.CORNER;
    currEllipseMode = pub.CENTER;
    currYAlign = VerticalJustification.TOP_ALIGN;
    start = Date.now();
    currFont = null;
    currImageMode = pub.CORNER;
    pub.resetMatrix();
  };

  var currentLayer = function() {
    if (!currLayer) {
      currentDoc();
      currLayer = app.activeDocument.activeLayer;
    }
    return currLayer;
  };
  
  var currentPage = function() {
    if (!currPage) {
      currentDoc();
      currPage = app.activeWindow.activePage;
    }
    return currPage;
  };

  var updatePublicPageSizeVars = function () {
    var pageBounds = currentPage().bounds; &#x2F;&#x2F; [y1, x1, y2, x2]
    var w = pageBounds[3] - pageBounds[1];
    var h = pageBounds[2] - pageBounds[0];
    pub.width = w;
    pub.height = h;
  };

  var error = function(msg) {
    $.writeln(ERROR_PREFIX + msg);
    throw ERROR_PREFIX + msg;
  };

  var warning = function(msg) {
    $.writeln(WARNING_PREFIX + msg);
  };
  
  init();
  
})(this, app);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
